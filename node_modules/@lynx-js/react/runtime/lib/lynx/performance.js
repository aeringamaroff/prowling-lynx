// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { options } from 'preact';
import { DIFF } from '../renderToOpcodes/constants.js';
import { __globalSnapshotPatch } from '../snapshotPatch.js';
var PerformanceTimingKeys;
(function (PerformanceTimingKeys) {
    PerformanceTimingKeys[PerformanceTimingKeys["update_set_state_trigger"] = 0] = "update_set_state_trigger";
    PerformanceTimingKeys[PerformanceTimingKeys["update_diff_vdom_start"] = 1] = "update_diff_vdom_start";
    PerformanceTimingKeys[PerformanceTimingKeys["update_diff_vdom_end"] = 2] = "update_diff_vdom_end";
    // update_set_state_trigger, update_diff_vdom_start and update_diff_vdom_end is deprecated
    PerformanceTimingKeys[PerformanceTimingKeys["diff_vdom_start"] = 3] = "diff_vdom_start";
    PerformanceTimingKeys[PerformanceTimingKeys["diff_vdom_end"] = 4] = "diff_vdom_end";
    PerformanceTimingKeys[PerformanceTimingKeys["pack_changes_start"] = 5] = "pack_changes_start";
    PerformanceTimingKeys[PerformanceTimingKeys["pack_changes_end"] = 6] = "pack_changes_end";
    PerformanceTimingKeys[PerformanceTimingKeys["parse_changes_start"] = 7] = "parse_changes_start";
    PerformanceTimingKeys[PerformanceTimingKeys["parse_changes_end"] = 8] = "parse_changes_end";
    PerformanceTimingKeys[PerformanceTimingKeys["patch_changes_start"] = 9] = "patch_changes_start";
    PerformanceTimingKeys[PerformanceTimingKeys["patch_changes_end"] = 10] = "patch_changes_end";
    PerformanceTimingKeys[PerformanceTimingKeys["hydrate_parse_snapshot_start"] = 11] = "hydrate_parse_snapshot_start";
    PerformanceTimingKeys[PerformanceTimingKeys["hydrate_parse_snapshot_end"] = 12] = "hydrate_parse_snapshot_end";
})(PerformanceTimingKeys || (PerformanceTimingKeys = {}));
/**
 * @deprecated used by old timing api(setState timing flag)
 */
const PerfSpecificKey = '__lynx_timing_flag';
let timingFlag;
let shouldMarkDiffVdomStart = false;
let shouldMarkDiffVdomEnd = false;
let globalPipelineOptions;
/**
 * @deprecated used by old timing api(setState timing flag)
 */
function markTimingLegacy(key, timingFlag_) {
    switch (key) {
        case PerformanceTimingKeys.update_set_state_trigger: {
            shouldMarkDiffVdomStart = true;
            shouldMarkDiffVdomEnd = true;
            timingFlag = timingFlag_;
            break;
        }
        case PerformanceTimingKeys.update_diff_vdom_start: {
            /* v8 ignore start */
            if (!shouldMarkDiffVdomStart) {
                return;
            }
            /* v8 ignore stop */
            shouldMarkDiffVdomStart = false;
            break;
        }
        case PerformanceTimingKeys.update_diff_vdom_end: {
            if (!shouldMarkDiffVdomEnd) {
                return;
            }
            shouldMarkDiffVdomEnd = false;
            break;
        }
    }
    lynx.getNativeApp().markTiming?.(timingFlag, PerformanceTimingKeys[key]);
}
function beginPipeline(needTimestamps, timingFlag) {
    globalPipelineOptions = lynx.performance?._generatePipelineOptions?.();
    if (globalPipelineOptions) {
        globalPipelineOptions.needTimestamps = needTimestamps;
        lynx.performance?._onPipelineStart?.(globalPipelineOptions.pipelineID);
        if (timingFlag) {
            lynx.performance?._bindPipelineIdWithTimingFlag?.(globalPipelineOptions.pipelineID, timingFlag);
        }
    }
}
function setPipeline(pipeline) {
    globalPipelineOptions = pipeline;
}
function markTiming(timestampKey, force) {
    if (globalPipelineOptions && (force || globalPipelineOptions.needTimestamps)) {
        lynx.performance?._markTiming?.(globalPipelineOptions.pipelineID, PerformanceTimingKeys[timestampKey]);
    }
}
function initTimingAPI() {
    const oldDiff = options[DIFF];
    options[DIFF] = (vnode) => {
        // check `__globalSnapshotPatch` to make sure this only runs after hydrate
        if (__JS__ && __globalSnapshotPatch) {
            if (!globalPipelineOptions) {
                beginPipeline(false);
                markTiming(PerformanceTimingKeys.diff_vdom_start, true);
            }
            if (shouldMarkDiffVdomStart) {
                markTimingLegacy(PerformanceTimingKeys.update_diff_vdom_start);
            }
        }
        oldDiff?.(vnode);
    };
}
/**
 * @internal
 */
export { PerformanceTimingKeys, PerfSpecificKey, markTimingLegacy, initTimingAPI, beginPipeline, markTiming, setPipeline, globalPipelineOptions, };
//# sourceMappingURL=performance.js.map