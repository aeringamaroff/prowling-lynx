// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { createSnapshot, SnapshotInstance, snapshotInstanceManager, snapshotManager } from './snapshot.js';
import { SnapshotOperation } from './snapshotPatch.js';
function reportCtxNotFound() {
    lynx.reportError(new Error(`snapshotPatchApply failed: ctx not found`));
}
export function snapshotPatchApply(snapshotPatch) {
    const length = snapshotPatch.length;
    for (let i = 0; i < length; ++i) {
        switch (snapshotPatch[i]) {
            case SnapshotOperation.CreateElement: {
                const type = snapshotPatch[++i];
                const id = snapshotPatch[++i];
                new SnapshotInstance(type, id);
                break;
            }
            case SnapshotOperation.InsertBefore: {
                const parentId = snapshotPatch[++i];
                const childId = snapshotPatch[++i];
                const beforeId = snapshotPatch[++i];
                const parent = snapshotInstanceManager.values.get(parentId);
                const child = snapshotInstanceManager.values.get(childId);
                const existingNode = snapshotInstanceManager.values.get(beforeId);
                if (!parent || !child) {
                    reportCtxNotFound();
                }
                else {
                    parent.insertBefore(child, existingNode);
                }
                break;
            }
            case SnapshotOperation.RemoveChild: {
                const parentId = snapshotPatch[++i];
                const childId = snapshotPatch[++i];
                const parent = snapshotInstanceManager.values.get(parentId);
                const child = snapshotInstanceManager.values.get(childId);
                if (!parent || !child) {
                    reportCtxNotFound();
                }
                else {
                    parent.removeChild(child);
                }
                break;
            }
            case SnapshotOperation.SetAttribute: {
                const id = snapshotPatch[++i];
                const dynamicPartIndex = snapshotPatch[++i];
                const value = snapshotPatch[++i];
                const si = snapshotInstanceManager.values.get(id);
                if (si) {
                    si.setAttribute(dynamicPartIndex, value);
                }
                else {
                    reportCtxNotFound();
                }
                break;
            }
            case SnapshotOperation.SetAttributes: {
                const id = snapshotPatch[++i];
                const values = snapshotPatch[++i];
                const si = snapshotInstanceManager.values.get(id);
                if (si) {
                    si.setAttribute('values', values);
                }
                else {
                    reportCtxNotFound();
                }
                break;
            }
            case SnapshotOperation.DEV_ONLY_AddSnapshot: {
                if (__DEV__) {
                    const uniqID = snapshotPatch[++i];
                    const create = snapshotPatch[++i];
                    const update = snapshotPatch[++i];
                    const slot = snapshotPatch[++i];
                    const cssId = snapshotPatch[++i] ?? 0;
                    const entryName = snapshotPatch[++i];
                    if (!snapshotManager.values.has(uniqID)) {
                        // HMR-related
                        // Update the evaluated snapshots from JS.
                        createSnapshot(uniqID, evaluate(create), update.map(evaluate), slot, cssId, entryName);
                    }
                }
                break;
            }
            case SnapshotOperation.DEV_ONLY_RegisterWorklet: {
                // HMR-related
                if (__DEV__) {
                    const hash = snapshotPatch[++i];
                    const fnStr = snapshotPatch[++i];
                    const fn = evaluate(fnStr);
                    registerWorklet('main-thread', hash, fn);
                }
                break;
            }
        }
    }
}
/**
 * Given an expression string, return the evaluated result with ReactLynx runtime injected.
 *
 * @param code - The code to be evaluated
 * @returns the evaluated expression
 */
function evaluate(code) {
    return new Function(`return ${code}`)();
}
//# sourceMappingURL=snapshotPatchApply.js.map