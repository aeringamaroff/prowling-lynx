"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var loader_exports = {};
__export(loader_exports, {
  addProbeLoader2Rules: () => addProbeLoader2Rules,
  createLoaderContextTrap: () => createLoaderContextTrap,
  extractLoaderName: () => extractLoaderName,
  getLoaderNameMatch: () => getLoaderNameMatch,
  isESMLoader: () => isESMLoader,
  loadLoaderModule: () => loadLoaderModule,
  mapEachRules: () => mapEachRules,
  parsePathQueryFragment: () => parsePathQueryFragment,
  parseQuery: () => parseQuery
});
module.exports = __toCommonJS(loader_exports);
var import_path = __toESM(require("path"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_lodash = require("lodash");
var import_common = require("@rsdoctor/utils/common");
var import_graph = require("@rsdoctor/graph");
var import_logger = require("@rsdoctor/utils/logger");
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
  return {
    path: match?.[1].replace(/\0(.)/g, "$1") || "",
    query: match?.[2] ? match[2].replace(/\0(.)/g, "$1") : "",
    fragment: match?.[3] || ""
  };
}
function loadLoaderModule(loaderPath, cwd = process.cwd()) {
  const cleanLoaderPath = parsePathQueryFragment(loaderPath).path;
  const mod = process.env.DOCTOR_TEST ? require(import_path.default.resolve(cwd, cleanLoaderPath)) : require(require.resolve(cleanLoaderPath, {
    paths: [cwd, import_path.default.resolve(cwd, "node_modules")]
  }));
  const isESM = mod.__esModule && typeof mod.default === "function";
  return {
    default: isESM ? mod.default : typeof mod === "function" ? mod : null,
    pitch: mod.default?.pitch || mod.pitch,
    raw: mod.default?.raw || mod.raw || false
  };
}
function extractLoaderName(loaderPath, cwd = "") {
  let res = loaderPath.replace(cwd, "");
  if (!import_path.default.isAbsolute(res))
    return res;
  const nms = "/node_modules/";
  const idx = res.lastIndexOf(nms);
  if (idx !== -1) {
    res = res.slice(idx + nms.length);
    const ln = "loader";
    const lnIdx = res.lastIndexOf(ln);
    if (lnIdx > -1) {
      res = res.slice(0, lnIdx + ln.length);
    }
  }
  return res;
}
function mapEachRules(rules, callback) {
  return rules.filter(Boolean).map((rule) => {
    if (typeof rule === "string") {
      return callback({
        loader: rule
      });
    }
    if (rule.loader && typeof rule.loader === "string") {
      return callback(rule);
    }
    if (Array.isArray(rule.loaders)) {
      const { loaders, ...rest } = rule;
      return {
        ...rest,
        use: mapEachRules(loaders, callback)
      };
    }
    if (rule.use && (!Array.isArray(rule.use) || rule.use.length !== 0)) {
      if (typeof rule.use === "string") {
        return {
          ...rule,
          use: mapEachRules(
            [
              {
                loader: rule.use,
                options: rule.options
              }
            ],
            callback
          )
        };
      }
      if (typeof rule.use === "function") {
        const funcUse = rule.use;
        const newRule = {
          ...rule,
          use: (...args) => {
            const rules2 = funcUse.apply(null, args);
            return mapEachRules(rules2, callback);
          }
        };
        return newRule;
      }
      if (Array.isArray(rule.use)) {
        return {
          ...rule,
          use: mapEachRules(rule.use, callback)
        };
      }
      return {
        ...rule,
        use: mapEachRules([rule.use], callback)
      };
    }
    if ("rules" in rule && Array.isArray(rule.rules)) {
      return {
        ...rule,
        rules: mapEachRules(rule.rules, callback)
      };
    }
    if (Array.isArray(rule.oneOf)) {
      return {
        ...rule,
        oneOf: mapEachRules(rule.oneOf, callback)
      };
    }
    return rule;
  });
}
function isESMLoader(r) {
  let _loaderName = typeof r === "object" && typeof r?.loader === "string" ? r.loader : typeof r === "string" ? r : "";
  if (!_loaderName)
    return false;
  const isPath = _loaderName.startsWith("/") || _loaderName.startsWith("./") || _loaderName.startsWith("../");
  if (isPath) {
    const packageJsonData = (0, import_graph.readPackageJson)(_loaderName, (file) => {
      try {
        return import_fs_extra.default.readJsonSync(file, { encoding: "utf8" });
      } catch (e) {
        (0, import_logger.debug)(() => `isESMLoader function errorï¼š${e}`);
      }
    });
    if (packageJsonData?.type === "module")
      return true;
  }
  return false;
}
function appendProbeLoaders(compiler, loaderConfig) {
  const _options = typeof loaderConfig === "object" ? typeof loaderConfig.options === "string" ? { options: loaderConfig.options } : loaderConfig.options : {};
  const loaderPath = import_path.default.join(__dirname, "../loader/probeLoader.js");
  const loader = typeof loaderConfig === "string" ? loaderConfig : typeof loaderConfig === "object" && loaderConfig.loader;
  const createProbeLoader = (type) => ({
    loader: loaderPath,
    options: {
      ..._options,
      loader,
      ident: void 0,
      type,
      builderName: compiler.options.name
    }
  });
  return [
    createProbeLoader("end"),
    loaderConfig,
    createProbeLoader("start")
  ];
}
function getLoaderNameMatch(r, loaderName, strict = true) {
  if (!strict) {
    return typeof r === "object" && typeof r?.loader === "string" && r.loader.includes(loaderName) || typeof r === "string" && r.includes(loaderName);
  }
  return typeof r === "object" && typeof r?.loader === "string" && r.loader === loaderName || typeof r === "string" && r === loaderName;
}
function addProbeLoader2Rules(rules, compiler, fn) {
  return rules.map((rule) => {
    if (!rule || typeof rule === "string")
      return rule;
    if (fn(rule) && !rule.use) {
      const loaderConfig = {
        loader: rule.loader ?? "",
        options: rule.options,
        ident: "ident" in rule && typeof rule.ident === "string" ? rule.ident : void 0
      };
      return {
        ...rule,
        use: appendProbeLoaders(compiler, loaderConfig),
        loader: void 0,
        options: void 0
      };
    }
    if (rule.use) {
      if (Array.isArray(rule.use)) {
        rule.use = rule.use.flatMap((loaderConfig) => {
          if (typeof loaderConfig === "string" || typeof loaderConfig === "object" && loaderConfig && "loader" in loaderConfig) {
            return fn(loaderConfig) ? appendProbeLoaders(compiler, loaderConfig) : [loaderConfig];
          }
          return [loaderConfig];
        });
      } else if (typeof rule.use === "object" && !Array.isArray(rule.use) && typeof rule.use !== "function") {
        if ("loader" in rule.use) {
          rule.use = fn(rule.use) ? appendProbeLoaders(compiler, rule.use) : [rule.use];
        }
      } else if (typeof rule.use === "string") {
        rule.use = fn(rule.use) ? appendProbeLoaders(compiler, { loader: rule.use }) : [
          {
            loader: rule.use
          }
        ];
      }
    }
    if ("oneOf" in rule && rule.oneOf) {
      return {
        ...rule,
        oneOf: addProbeLoader2Rules(rule.oneOf, compiler, fn)
      };
    }
    if ("rules" in rule && rule.rules) {
      return {
        ...rule,
        rules: addProbeLoader2Rules(rule.rules, compiler, fn)
      };
    }
    return rule;
  });
}
function createLoaderContextTrap(final) {
  const cb = this.callback;
  let callback = (...args) => {
    final(args[0], args[1] ?? null, args[2]);
    return cb.call(this, ...args);
  };
  const ac = this.async;
  let async = (...args) => {
    const cb2 = ac(...args);
    return (...args2) => {
      final(args2[0], args2[1] ?? null, args2[2]);
      return cb2(...args2);
    };
  };
  const trap = new Proxy(this, {
    get(target, key, receiver) {
      switch (key) {
        case "async":
          return async;
        case "callback":
          return callback;
        case "query":
          if (target.query) {
            if (typeof target.query === "string") {
              const res = target.query.replace(
                // eslint-disable-next-line no-useless-escape
                new RegExp(
                  `"${import_common.Loader.LoaderInternalPropertyName}":{[^}]*},{0,1}`
                ),
                ""
              );
              return res;
            }
            if (typeof target.query === "object") {
              const options = target.query[import_common.Loader.LoaderInternalPropertyName];
              if (options.hasOptions) {
                return (0, import_lodash.omit)(target.query, [import_common.Loader.LoaderInternalPropertyName]);
              }
              const innerLoaderPath = options?.loader;
              const loaderQuery = parsePathQueryFragment(innerLoaderPath).query;
              return loaderQuery;
            }
          }
          return Reflect.get(target, key, receiver);
        case "getOptions":
          return typeof target.getOptions === "function" ? () => (0, import_lodash.omit)(target.getOptions(), [import_common.Loader.LoaderInternalPropertyName]) : Reflect.get(target, key, receiver);
        default:
          const _target = target;
          return _target[key];
      }
    },
    set(target, key, value, receiver) {
      switch (key) {
        case "async":
          async = value;
          return true;
        case "callback":
          callback = value;
          return true;
        default:
          return Reflect.set(target, key, value, receiver);
      }
    },
    defineProperty(target, p, attrs) {
      return Reflect.defineProperty(target, p, attrs);
    }
  });
  return trap;
}
function parseQuery(query) {
  if (query.startsWith("?")) {
    query = query.slice(1);
  }
  const searchParams = new URLSearchParams(query);
  return Object.fromEntries(searchParams.entries());
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addProbeLoader2Rules,
  createLoaderContextTrap,
  extractLoaderName,
  getLoaderNameMatch,
  isESMLoader,
  loadLoaderModule,
  mapEachRules,
  parsePathQueryFragment,
  parseQuery
});
