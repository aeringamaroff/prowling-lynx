import fse from "fs-extra";
import path from "path";
import { DevToolError } from "@rsdoctor/utils/error";
import { Constants, SDK } from "@rsdoctor/types";
import { File } from "@rsdoctor/utils/build";
import { SourceMapConsumer } from "source-map";
import { ModuleGraph, ChunkGraph, PackageGraph } from "@rsdoctor/graph";
import { debug } from "@rsdoctor/utils/logger";
import { RsdoctorServer } from "../server";
import { RsdoctorFakeServer } from "../server/fakeServer";
import { SDKCore } from "./core";
import { Algorithm } from "@rsdoctor/utils/common";
import { isNumber } from "lodash";
const jc = require("json-cycle");
export * from "../utils/openBrowser";
class RsdoctorSDK extends SDKCore {
  constructor(options) {
    super(options);
    this._summary = { costs: [] };
    this._configs = [];
    this._errors = [];
    this._loader = [];
    this._loaderStart = [];
    this._resolver = [];
    this._plugin = {};
    this._moduleGraph = new ModuleGraph();
    this._chunkGraph = new ChunkGraph();
    this._rawSourceMapCache = /* @__PURE__ */ new Map();
    this._sourceMap = /* @__PURE__ */ new Map();
    this.server = options.config?.noServer ? new RsdoctorFakeServer(this, void 0) : new RsdoctorServer(this, options.port, {
      innerClientPath: options.config?.innerClientPath || "",
      printServerUrl: options.config?.printLog?.serverUrls
    });
    this.type = isNumber(options.type) ? options.type : SDK.ToDataType.Normal;
    this.extraConfig = options.config;
  }
  async bootstrap() {
    debug(() => `${Date.now()}`, "[RsdoctorSDK][bootstrap start]");
    this.server && await this.server.bootstrap();
    await super.bootstrap();
    debug(
      () => `${Date.now()} ${this.server.origin}`,
      "[RsdoctorSDK][bootstrap end]"
    );
  }
  async dispose() {
    debug(() => `${Date.now()}`, "[RsdoctorSDK][dispose start]");
    this.server && await this.server.dispose();
    await super.dispose();
    debug(() => `${Date.now()}`, "[RsdoctorSDK][dispose end]");
  }
  async applyErrorFix(id) {
    const { _errors: errors } = this;
    const error = errors.find((err) => err.id === id);
    if (!error || !error.path || !error.fixData || error.fixData.isFixed) {
      return;
    }
    const { path: filePath, fixData } = error;
    const sameFileErrors = errors.filter(
      (item) => item.path === filePath && item !== error
    );
    let content = (await File.fse.readFile(filePath, "utf-8")).toString();
    const startTxt = content.substring(0, fixData.start);
    const endTxt = content.substring(fixData.end, content.length);
    const offset = (fixData.newText ?? "").length - (fixData.end - fixData.start);
    content = startTxt + fixData.newText + endTxt;
    for (const other of sameFileErrors) {
      const { fixData: otherFixData } = other;
      if (!otherFixData) {
        continue;
      }
      if (otherFixData.start >= fixData.end) {
        otherFixData.start += offset;
        otherFixData.end += offset;
      }
    }
    await File.fse.writeFile(filePath, content);
  }
  clear() {
    this._errors = [];
    this._loader = [];
    this._resolver = [];
    this._plugin = {};
    this._moduleGraph = new ModuleGraph();
    this._chunkGraph = new ChunkGraph();
  }
  clearSourceMapCache() {
    this._rawSourceMapCache = /* @__PURE__ */ new Map();
    this._sourceMap = /* @__PURE__ */ new Map();
  }
  async getSourceMap(file) {
    const { _sourceMap: sourceMap, _rawSourceMapCache: rawMap } = this;
    if (sourceMap.has(file)) {
      return sourceMap.get(file);
    }
    const rawData = rawMap.get(file);
    if (!rawData || rawData.version < 0 || !rawData.sourcesContent?.[0] || !rawData.mappings) {
      return Promise.resolve(void 0);
    }
    try {
      const result = await new SourceMapConsumer(rawData);
      sourceMap.set(file, result);
      return result;
    } catch (e) {
      return Promise.resolve(void 0);
    }
  }
  reportSourceMap(data) {
    this._rawSourceMapCache.set(data.file, data);
  }
  reportConfiguration(config) {
    this._configs.push(config);
    this.onDataReport();
  }
  reportError(errors) {
    errors.forEach((item) => {
      this._errors.push(
        DevToolError.from(item, {
          code: this.name
        })
      );
    });
    this.onDataReport();
  }
  reportLoader(data) {
    data.forEach((item) => {
      if (this.extraConfig?.mode === SDK.IMode[SDK.IMode.brief]) {
        item.loaders.forEach((_loader) => {
          _loader.input = "";
          _loader.result = "";
        });
      }
      let match = this._loader.find(
        (e) => e.resource.path === item.resource.path
      );
      if (match) {
        match.loaders.push(...item.loaders);
      } else {
        match = item;
        this._loader.push(item);
      }
      match.loaders.sort((a, b) => {
        if (a.startAt !== b.startAt) {
          return a.startAt - b.startAt;
        }
        if (a.isPitch) {
          if (b.isPitch) {
            return a.loaderIndex - b.loaderIndex;
          }
          return -1;
        }
        if (b.isPitch) {
          return 1;
        }
        return b.loaderIndex - a.loaderIndex;
      });
    });
    this.onDataReport();
  }
  reportLoaderStartOrEnd(data) {
    const _builtinLoader = data.loaders[0];
    if (_builtinLoader.startAt) {
      this._loaderStart.push(data);
    } else if (_builtinLoader.endAt) {
      const matchLoaderStart = this._loaderStart.find(
        (e) => e.resource.path === data.resource.path && e.loaders[0].loader === _builtinLoader.loader
      );
      if (matchLoaderStart) {
        matchLoaderStart.loaders[0].result = _builtinLoader.result;
        matchLoaderStart.loaders[0].endAt = _builtinLoader.endAt;
        this.reportLoader([matchLoaderStart]);
      }
    }
  }
  reportResolver(data) {
    data.forEach((item) => this._resolver.push(item));
    this.onDataReport();
  }
  reportPlugin(data) {
    Object.keys(data).forEach((hook) => {
      if (!this._plugin[hook]) {
        this._plugin[hook] = data[hook];
      } else {
        data[hook].forEach((item) => {
          this._plugin[hook].push(item);
        });
      }
    });
    this.onDataReport();
  }
  reportModuleGraph(data) {
    debug(() => `data size: ${data.size()}`, "[SDK.reportModuleGraph][start]");
    this._moduleGraph.fromInstance(data);
    this.createPackageGraph();
    this.onDataReport();
    debug(
      () => `sdk._moduleGraph size: ${this._moduleGraph.size()}`,
      "[SDK reportModuleGraph][end]"
    );
  }
  reportPackageGraph(data) {
    debug(() => "[SDK.reportPackageGraph][start]");
    if (!this._packageGraph) {
      this._packageGraph = data;
    }
    this.onDataReport();
    debug(
      () => `sdk._moduleGraph size: ${this._moduleGraph.size()}`,
      "[SDK reportPackageGraph][end]"
    );
  }
  reportChunkGraph(data) {
    this._chunkGraph.addAsset(...data.getAssets());
    this._chunkGraph.addChunk(...data.getChunks());
    this._chunkGraph.addEntryPoint(...data.getEntryPoints());
    this.onDataReport();
  }
  reportSummaryData(part) {
    const keys = ["costs"];
    for (const key of keys) {
      const v = part[key];
      if (!v)
        continue;
      if (typeof v === "object") {
        if (Array.isArray(v)) {
          this._summary[key] = [
            ...this._summary[key] || [],
            ...v
          ];
        } else {
          this._summary[key] = {
            ...this._summary[key] || {},
            ...v
          };
        }
      } else {
        this._summary[key] = v;
      }
    }
    this.onDataReport();
  }
  reportTileHtml(tileReportHtml) {
    this._tileReportHtml = tileReportHtml;
  }
  createPackageGraph() {
    debug(
      () => `sdk._moduleGraph size: ${this._moduleGraph.size()}`,
      "[SDK.createPackageGraph][start]"
    );
    if (!this._packageGraph) {
      const pkgGraph = PackageGraph.fromModuleGraph(
        this._moduleGraph,
        this.root,
        (path2) => {
          try {
            const exists = File.fse.existsSync(path2);
            if (exists) {
              debug(
                () => `sdk.PackageGraph package.json exists: ${exists}, path: ${path2}`,
                "[SDK.createPackageGraph][load]"
              );
              return File.fse.readJSONSync(path2);
            }
          } catch (error) {
            const { message, stack } = error;
            debug(
              () => `sdk.createPackageGraph error, path: ${path2}, error message: ${stack || message}`,
              "[SDK.createPackageGraph][error]"
            );
          }
        }
      );
      this._packageGraph = pkgGraph;
      debug(
        () => `sdk._packageGraph packages: ${this._packageGraph.getPackages().length}`,
        "[SDK.createPackageGraph][end]"
      );
    }
  }
  async writeStore(options) {
    debug(() => `sdk.writeStore has run.`, "[SDK.writeStore][end]");
    if (this.extraConfig?.mode === SDK.IMode[SDK.IMode.brief]) {
      const clientHtmlPath = this.extraConfig.innerClientPath ? this.extraConfig.innerClientPath : require.resolve("@rsdoctor/client");
      if (this.extraConfig.brief?.writeDataJson) {
        await this.saveManifest(this.getStoreData(), options || {});
      }
      return this.inlineScriptsAndStyles(clientHtmlPath);
    }
    return this.saveManifest(this.getStoreData(), options || {});
  }
  getStoreData() {
    const ctx = this;
    return {
      get hash() {
        return ctx.hash;
      },
      get root() {
        return ctx.root;
      },
      get envinfo() {
        return ctx._envinfo;
      },
      get pid() {
        return ctx.pid;
      },
      get errors() {
        return ctx._errors.map((err) => err.toData());
      },
      get configs() {
        return ctx._configs.slice();
      },
      get summary() {
        return { ...ctx._summary };
      },
      get resolver() {
        return ctx._resolver.slice();
      },
      get loader() {
        return ctx._loader.slice();
      },
      get moduleGraph() {
        return ctx._moduleGraph.toData({
          contextPath: ctx._configs?.[0]?.config?.context || ""
        });
      },
      get chunkGraph() {
        return ctx._chunkGraph.toData(ctx.type);
      },
      get moduleCodeMap() {
        return ctx._moduleGraph.toCodeData(ctx.type);
      },
      get plugin() {
        return { ...ctx._plugin };
      },
      get packageGraph() {
        return ctx._packageGraph ? ctx._packageGraph.toData() : {
          packages: [],
          dependencies: []
        };
      },
      get otherReports() {
        return { tileReportHtml: ctx._tileReportHtml || "" };
      }
    };
  }
  getManifestData() {
    const dataValue = this.getStoreData();
    const data = {
      client: {
        enableRoutes: this.getClientRoutes()
      },
      data: Object.keys(dataValue).reduce((t, e) => {
        const _e = e;
        if (dataValue[_e] && typeof dataValue[_e] === "object") {
          t[e] = [
            `${this.server.origin}${SDK.ServerAPI.API.LoadDataByKey}/${e}`
          ];
        } else {
          t[e] = dataValue[_e];
        }
        return t;
      }, {}),
      __LOCAL__SERVER__: true,
      __SOCKET__PORT__: this.server.socketUrl.port.toString(),
      __SOCKET__URL__: this.server.socketUrl.socketUrl
    };
    return data;
  }
  getRuleContext(_options) {
    this.createPackageGraph();
    return {
      root: this.root,
      errors: this._errors.slice(),
      configs: this._configs.slice(),
      moduleGraph: this._moduleGraph,
      chunkGraph: this._chunkGraph,
      packageGraph: this._packageGraph,
      loader: this._loader.slice(),
      otherReports: { tileReportHtml: this._tileReportHtml || "" }
    };
  }
  onDataReport() {
    this.server.broadcast();
  }
  addRsdoctorDataToHTML(storeData, htmlContent) {
    let compressTextScripts = `<script>window.${Constants.WINDOW_RSDOCTOR_TAG}={}</script>`;
    for (let key of Object.keys(storeData)) {
      const data = storeData[key];
      const jsonStrFn = () => {
        try {
          if (key === "configs") {
            return JSON.stringify(jc.decycle(data));
          }
          return JSON.stringify(data);
        } catch (error) {
          console.error(error);
          return "";
        }
      };
      const compressText = Algorithm.compressText(jsonStrFn());
      compressTextScripts = `${compressTextScripts} <script>window.${Constants.WINDOW_RSDOCTOR_TAG}.${key}=${JSON.stringify(compressText)}</script>`;
    }
    compressTextScripts = `${compressTextScripts} <script>window.${Constants.WINDOW_RSDOCTOR_TAG}.enableRoutes=${JSON.stringify(this.getClientRoutes())}</script>`;
    htmlContent = htmlContent.replace("<body>", `<body>${compressTextScripts}`);
    return htmlContent;
  }
  inlineScriptsAndStyles(htmlFilePath) {
    function inlineScripts(basePath2, scripts) {
      return scripts.map((src) => {
        const scriptPath = path.resolve(basePath2, src);
        try {
          const scriptContent = fse.readFileSync(scriptPath, "utf-8");
          return `<script>${scriptContent}</script>`;
        } catch (error) {
          console.error(`Could not read script at ${scriptPath}:`, error);
          return "";
        }
      }).join("");
    }
    function inlineCss(basePath2, cssFiles) {
      return cssFiles.map((href) => {
        const cssPath = path.resolve(basePath2, href);
        try {
          const cssContent = fse.readFileSync(cssPath, "utf-8");
          return `<style>${cssContent}</style>`;
        } catch (error) {
          console.error(`Could not read CSS at ${cssPath}:`, error);
          return "";
        }
      }).join("");
    }
    let htmlContent = fse.readFileSync(htmlFilePath, "utf-8");
    const basePath = path.dirname(htmlFilePath);
    const scriptSrcs = Array.from(
      htmlContent.matchAll(
        /<script\s+(?:defer="defer"|defer)\s+src=["'](.+?)["']><\/script>/g
      ),
      (m) => m[1]
    );
    const cssHrefs = Array.from(
      htmlContent.matchAll(/<link\s+href=["'](.+?)["']\s+rel="stylesheet">/g),
      (m) => m[1]
    );
    htmlContent = htmlContent.replace(
      /<script\s+.*?src=["'].*?["']><\/script>/g,
      ""
    );
    htmlContent = htmlContent.replace(
      /<link\s+.*?rel=["']stylesheet["'].*?>/g,
      ""
    );
    const inlinedScripts = inlineScripts(basePath, scriptSrcs);
    const inlinedCss = inlineCss(basePath, cssHrefs);
    const index = htmlContent.indexOf("</body>");
    htmlContent = htmlContent.slice(0, index) + inlinedCss + inlinedScripts + htmlContent.slice(index);
    htmlContent = this.addRsdoctorDataToHTML(this.getStoreData(), htmlContent);
    const outputFilePath = path.resolve(
      this.outputDir,
      this.extraConfig?.brief?.reportHtmlName || "rsdoctor-report.html"
    );
    fse.outputFileSync(outputFilePath, htmlContent, {
      encoding: "utf-8",
      flag: "w"
    });
    return outputFilePath;
  }
}
export {
  RsdoctorSDK
};
