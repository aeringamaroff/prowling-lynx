import { LlmSchemaComposer } from "./LlmSchemaComposer.mjs";

var HttpLlmComposer;

(function(HttpLlmComposer) {
    HttpLlmComposer.application = props => {
        const errors = props.migrate.errors.filter((e => e.operation()["x-samchon-human"] !== true)).map((e => ({
            method: e.method,
            path: e.path,
            messages: e.messages,
            operation: () => e.operation(),
            route: () => undefined
        })));
        const functions = props.migrate.routes.filter((e => e.operation()["x-samchon-human"] !== true)).map(((route, i) => {
            if (route.method === "head") {
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: [ "HEAD method is not supported in the LLM application." ],
                    operation: () => route.operation(),
                    route: () => route
                });
                return null;
            } else if (route.body?.type === "multipart/form-data" || route.success?.type === "multipart/form-data") {
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: [ `The "multipart/form-data" content type is not supported in the LLM application.` ],
                    operation: () => route.operation(),
                    route: () => route
                });
                return null;
            }
            const localErrors = [];
            const func = composeFunction({
                model: props.model,
                options: props.options,
                components: props.migrate.document().components,
                route,
                errors: localErrors
            });
            if (func === null) errors.push({
                method: route.method,
                path: route.path,
                messages: localErrors,
                operation: () => route.operation(),
                route: () => route
            });
            return func;
        })).filter((v => v !== null));
        const app = {
            model: props.model,
            options: props.options,
            functions,
            errors
        };
        HttpLlmComposer.shorten(app, props.options?.maxLength ?? 64);
        return app;
    };
    const composeFunction = props => {
        const $defs = {};
        const cast = (s, accessor) => {
            const result = LlmSchemaComposer.schema(props.model)({
                config: props.options,
                schema: s,
                components: props.components,
                $defs,
                accessor,
                refAccessor: `$input.components.schemas`
            });
            if (result.success === false) {
                props.errors.push(...result.error.reasons.map((r => `${r.accessor}: ${r.message}`)));
                return null;
            }
            return result.value;
        };
        const endpoint = `$input.paths[${JSON.stringify(props.route.path)}][${JSON.stringify(props.route.method)}]`;
        const output = props.route.success ? cast(props.route.success.schema, `${endpoint}.responses[${JSON.stringify(props.route.success.status)}][${JSON.stringify(props.route.success.type)}].schema`) : undefined;
        const properties = [ ...props.route.parameters.map((s => [ s.key, cast({
            ...s.schema,
            title: s.parameter().title ?? s.schema.title,
            description: s.parameter().description ?? s.schema.description
        }, `${endpoint}.parameters[${JSON.stringify(s.key)}].schema`) ])), ...props.route.query ? [ [ props.route.query.key, cast({
            ...props.route.query.schema,
            title: props.route.query.title() ?? props.route.query.schema.title,
            description: props.route.query.description() ?? props.route.query.schema.description
        }, `${endpoint}.parameters[${JSON.stringify(props.route.query.key)}].schema`) ] ] : [], ...props.route.body ? [ [ props.route.body.key, cast({
            ...props.route.body.schema,
            description: props.route.body.description() ?? props.route.body.schema.description
        }, `${endpoint}.requestBody.content[${JSON.stringify(props.route.body.type)}].schema`) ] ] : [] ];
        const operation = props.route.operation();
        const description = (() => {
            if (!operation.summary?.length || !operation.description?.length) return [ operation.summary || operation.description, operation.summary?.length ?? operation.description?.length ?? 0 ];
            const summary = operation.summary.endsWith(".") ? operation.summary.slice(0, -1) : operation.summary;
            const final = operation.description.startsWith(summary) ? operation.description : summary + ".\n\n" + operation.description;
            return [ final, final.length ];
        })();
        if (description[1] > 1024) {
            props.errors.push(`The description of the function is too long (must be equal or less than 1,024 characters, but ${description[1].toLocaleString()} length).`);
        }
        const name = emend(props.route.accessor.join("_"));
        const isNameVariable = /^[a-zA-Z0-9_-]+$/.test(name);
        const isNameStartsWithNumber = /^[0-9]/.test(name[0] ?? "");
        if (isNameVariable === false) props.errors.push(`Elements of path (separated by '/') must be composed with alphabets, numbers, underscores, and hyphens`);
        if (output === null || properties.some((([_k, v]) => v === null)) || isNameVariable === false || isNameStartsWithNumber === true || description[1] > 1024) return null;
        const parameters = {
            type: "object",
            properties: Object.fromEntries(properties),
            additionalProperties: false,
            required: properties.map((([k]) => k))
        };
        if (LlmSchemaComposer.isDefs(props.model)) parameters.$defs = $defs;
        return {
            method: props.route.method,
            path: props.route.path,
            name,
            parameters,
            separated: props.options.separate ? LlmSchemaComposer.separateParameters(props.model)({
                predicate: props.options.separate,
                parameters
            }) : undefined,
            output,
            description: description[0],
            deprecated: operation.deprecated,
            tags: operation.tags,
            route: () => props.route,
            operation: () => props.route.operation()
        };
    };
    HttpLlmComposer.shorten = (app, limit = 64) => {
        const dictionary = new Set;
        const longFunctions = [];
        for (const func of app.functions) {
            dictionary.add(func.name);
            if (func.name.length > limit) {
                longFunctions.push(func);
            }
        }
        if (longFunctions.length === 0) return;
        let index = 0;
        for (const func of longFunctions) {
            let success = false;
            let rename = str => {
                dictionary.delete(func.name);
                dictionary.add(str);
                func.name = str;
                success = true;
            };
            for (let i = 1; i < func.route().accessor.length; ++i) {
                const shortName = func.route().accessor.slice(i).join("_");
                if (shortName.length > limit - 8) continue; else if (dictionary.has(shortName) === false) rename(shortName); else {
                    const newName = `_${index}_${shortName}`;
                    if (dictionary.has(newName) === true) continue;
                    rename(newName);
                    ++index;
                }
                break;
            }
            if (success === false) rename(randomFormatUuid());
        }
    };
})(HttpLlmComposer || (HttpLlmComposer = {}));

const randomFormatUuid = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
}));

const emend = str => {
    for (const ch of FORBIDDEN) str = str.split(ch).join("_");
    return str;
};

const FORBIDDEN = [ "$", "%", "." ];

export { HttpLlmComposer };
//# sourceMappingURL=HttpLlmApplicationComposer.mjs.map
