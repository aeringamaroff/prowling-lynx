{"version":3,"file":"ChatGptSchemaComposer.mjs","sources":["../../../src/composers/llm/ChatGptSchemaComposer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { IChatGptSchema } from \"../../structures/IChatGptSchema\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3_1 } from \"../../structures/ILlmSchemaV3_1\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../typings/IResult\";\nimport { ChatGptTypeChecker } from \"../../utils/ChatGptTypeChecker\";\nimport { LlmTypeCheckerV3_1 } from \"../../utils/LlmTypeCheckerV3_1\";\nimport { NamingConvention } from \"../../utils/NamingConvention\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { LlmDescriptionInverter } from \"./LlmDescriptionInverter\";\nimport { LlmSchemaV3_1Composer } from \"./LlmSchemaV3_1Composer\";\n\nexport namespace ChatGptSchemaComposer {\n  /**\n   * @internal\n   */\n  export const IS_DEFS = true;\n\n  /* -----------------------------------------------------------\n    CONVERTERS\n  ----------------------------------------------------------- */\n  export const parameters = (props: {\n    config: IChatGptSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IChatGptSchema.IParameters, IOpenApiSchemaError> => {\n    // polyfill\n    props.config.strict ??= false;\n\n    // validate\n    const result: IResult<ILlmSchemaV3_1.IParameters, IOpenApiSchemaError> =\n      LlmSchemaV3_1Composer.parameters({\n        ...props,\n        config: {\n          reference: props.config.reference,\n          constraint: false,\n        },\n        validate: props.config.strict === true ? validateStrict : undefined,\n      });\n    if (result.success === false) return result;\n\n    // returns with transformation\n    for (const key of Object.keys(result.value.$defs))\n      result.value.$defs[key] = transform({\n        config: props.config,\n        schema: result.value.$defs[key],\n      });\n    return {\n      success: true,\n      value: transform({\n        config: props.config,\n        schema: result.value,\n      }) as IChatGptSchema.IParameters,\n    };\n  };\n\n  export const schema = (props: {\n    config: IChatGptSchema.IConfig;\n    components: OpenApi.IComponents;\n    $defs: Record<string, IChatGptSchema>;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IChatGptSchema, IOpenApiSchemaError> => {\n    // polyfill\n    props.config.strict ??= false;\n\n    // validate\n    const oldbie: Set<string> = new Set(Object.keys(props.$defs));\n    const result: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n      LlmSchemaV3_1Composer.schema({\n        ...props,\n        config: {\n          reference: props.config.reference,\n          constraint: false,\n        },\n        validate: props.config.strict === true ? validateStrict : undefined,\n      });\n    if (result.success === false) return result;\n\n    // returns with transformation\n    for (const key of Object.keys(props.$defs))\n      if (oldbie.has(key) === false)\n        props.$defs[key] = transform({\n          config: props.config,\n          schema: props.$defs[key],\n        });\n    return {\n      success: true,\n      value: transform({\n        config: props.config,\n        schema: result.value,\n      }),\n    };\n  };\n\n  const validateStrict = (\n    schema: OpenApi.IJsonSchema,\n    accessor: string,\n  ): IOpenApiSchemaError.IReason[] => {\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    if (OpenApiTypeChecker.isObject(schema)) {\n      if (!!schema.additionalProperties)\n        reasons.push({\n          schema: schema,\n          accessor: `${accessor}.additionalProperties`,\n          message:\n            \"ChatGPT does not allow additionalProperties in strict mode, the dynamic key typed object.\",\n        });\n      for (const key of Object.keys(schema.properties ?? {}))\n        if (schema.required?.includes(key) === false)\n          reasons.push({\n            schema: schema,\n            accessor: `${accessor}.properties.${key}`,\n            message:\n              \"ChatGPT does not allow optional properties in strict mode.\",\n          });\n    }\n    return reasons;\n  };\n\n  const transform = (props: {\n    config: IChatGptSchema.IConfig;\n    schema: ILlmSchemaV3_1;\n  }): IChatGptSchema => {\n    const union: Array<IChatGptSchema> = [];\n    const attribute: IChatGptSchema.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      example: props.schema.example,\n      examples: props.schema.examples,\n      ...Object.fromEntries(\n        Object.entries(schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n    };\n    const visit = (input: ILlmSchemaV3_1): void => {\n      if (LlmTypeCheckerV3_1.isOneOf(input)) input.oneOf.forEach(visit);\n      else if (LlmTypeCheckerV3_1.isArray(input))\n        union.push({\n          ...input,\n          items: transform({\n            config: props.config,\n            schema: input.items,\n          }),\n        });\n      else if (LlmTypeCheckerV3_1.isObject(input))\n        union.push({\n          ...input,\n          properties: Object.fromEntries(\n            Object.entries(input.properties).map(([key, value]) => [\n              key,\n              transform({\n                config: props.config,\n                schema: value,\n              }),\n            ]),\n          ),\n          additionalProperties:\n            props.config.strict === true\n              ? false\n              : typeof input.additionalProperties === \"object\" &&\n                  input.additionalProperties !== null\n                ? transform({\n                    config: props.config,\n                    schema: input.additionalProperties,\n                  })\n                : input.additionalProperties,\n        });\n      else if (LlmTypeCheckerV3_1.isConstant(input) === false)\n        union.push(input);\n    };\n    const visitConstant = (input: ILlmSchemaV3_1): void => {\n      const insert = (value: any): void => {\n        const matched: IChatGptSchema.IString | undefined = union.find(\n          (u) =>\n            (u as IChatGptSchema.__ISignificant<any> | undefined)?.type ===\n            typeof value,\n        ) as IChatGptSchema.IString | undefined;\n        if (matched !== undefined) {\n          matched.enum ??= [];\n          matched.enum.push(value);\n        } else\n          union.push({\n            type: typeof value as \"number\",\n            enum: [value],\n          });\n      };\n      if (OpenApiTypeChecker.isConstant(input)) insert(input.const);\n      else if (OpenApiTypeChecker.isOneOf(input))\n        input.oneOf.forEach(visitConstant);\n    };\n    visit(props.schema);\n    visitConstant(props.schema);\n    if (union.length === 0)\n      return {\n        ...attribute,\n        type: undefined,\n      };\n    else if (union.length === 1)\n      return {\n        ...attribute,\n        ...union[0],\n        description: ChatGptTypeChecker.isReference(union[0]!)\n          ? undefined\n          : (union[0].description ?? attribute.description),\n      };\n    return {\n      ...attribute,\n      anyOf: union.map((u) => ({\n        ...u,\n        description: ChatGptTypeChecker.isReference(u)\n          ? undefined\n          : u.description,\n      })),\n    };\n  };\n\n  /* -----------------------------------------------------------\n    SEPARATORS\n  ----------------------------------------------------------- */\n  export const separateParameters = (props: {\n    parameters: IChatGptSchema.IParameters;\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention?: (key: string, type: \"llm\" | \"human\") => string;\n  }): ILlmFunction.ISeparated<\"chatgpt\"> => {\n    const convention =\n      props.convention ??\n      ((key, type) => `${key}.${NamingConvention.capitalize(type)}`);\n    const [llm, human] = separateObject({\n      predicate: props.predicate,\n      convention,\n      $defs: props.parameters.$defs,\n      schema: props.parameters,\n    });\n    if (llm === null || human === null)\n      return {\n        llm: (llm as IChatGptSchema.IParameters | null) ?? {\n          type: \"object\",\n          properties: {} as Record<string, IChatGptSchema>,\n          required: [],\n          additionalProperties: false,\n          $defs: {},\n        },\n        human: human as IChatGptSchema.IParameters | null,\n      };\n    const output: ILlmFunction.ISeparated<\"chatgpt\"> = {\n      llm: {\n        ...llm,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Llm\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n      human: {\n        ...human,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Human\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n    };\n    for (const key of Object.keys(props.parameters.$defs))\n      if (key.endsWith(\".Llm\") === false && key.endsWith(\".Human\") === false)\n        delete props.parameters.$defs[key];\n    return output;\n  };\n\n  const separateStation = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, IChatGptSchema>;\n    schema: IChatGptSchema;\n  }): [IChatGptSchema | null, IChatGptSchema | null] => {\n    if (props.predicate(props.schema) === true) return [null, props.schema];\n    else if (\n      ChatGptTypeChecker.isUnknown(props.schema) ||\n      ChatGptTypeChecker.isAnyOf(props.schema)\n    )\n      return [props.schema, null];\n    else if (ChatGptTypeChecker.isObject(props.schema))\n      return separateObject({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (ChatGptTypeChecker.isArray(props.schema))\n      return separateArray({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (ChatGptTypeChecker.isReference(props.schema))\n      return separateReference({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    return [props.schema, null];\n  };\n\n  const separateArray = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, IChatGptSchema>;\n    schema: IChatGptSchema.IArray;\n  }): [IChatGptSchema.IArray | null, IChatGptSchema.IArray | null] => {\n    const [x, y] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema: props.schema.items,\n    });\n    return [\n      x !== null\n        ? {\n            ...props.schema,\n            items: x,\n          }\n        : null,\n      y !== null\n        ? {\n            ...props.schema,\n            items: y,\n          }\n        : null,\n    ];\n  };\n\n  const separateObject = (props: {\n    $defs: Record<string, IChatGptSchema>;\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    schema: IChatGptSchema.IObject;\n  }): [IChatGptSchema.IObject | null, IChatGptSchema.IObject | null] => {\n    // EMPTY OBJECT\n    if (\n      Object.keys(props.schema.properties ?? {}).length === 0 &&\n      !!props.schema.additionalProperties === false\n    )\n      return [props.schema, null];\n\n    const llm = {\n      ...props.schema,\n      properties: {} as Record<string, IChatGptSchema>,\n      additionalProperties: props.schema.additionalProperties,\n    } satisfies IChatGptSchema.IObject;\n    const human = {\n      ...props.schema,\n      properties: {} as Record<string, IChatGptSchema>,\n    } satisfies IChatGptSchema.IObject;\n\n    for (const [key, value] of Object.entries(props.schema.properties ?? {})) {\n      const [x, y] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: value,\n      });\n      if (x !== null) llm.properties[key] = x;\n      if (y !== null) human.properties[key] = y;\n    }\n    if (\n      typeof props.schema.additionalProperties === \"object\" &&\n      props.schema.additionalProperties !== null\n    ) {\n      const [dx, dy] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema.additionalProperties,\n      });\n      llm.additionalProperties = dx ?? false;\n      human.additionalProperties = dy ?? false;\n    }\n    return [\n      !!Object.keys(llm.properties).length || !!llm.additionalProperties\n        ? shrinkRequired(llm)\n        : null,\n      !!Object.keys(human.properties).length || human.additionalProperties\n        ? shrinkRequired(human)\n        : null,\n    ];\n  };\n\n  const separateReference = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, IChatGptSchema>;\n    schema: IChatGptSchema.IReference;\n  }): [IChatGptSchema.IReference | null, IChatGptSchema.IReference | null] => {\n    const key: string = props.schema.$ref.split(\"#/$defs/\")[1];\n    const humanKey: string = props.convention(key, \"human\");\n    const llmKey: string = props.convention(key, \"llm\");\n\n    // FIND EXISTING\n    if (props.$defs?.[humanKey] || props.$defs?.[llmKey])\n      return [\n        props.$defs?.[llmKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${llmKey}`,\n            }\n          : null,\n        props.$defs?.[humanKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${humanKey}`,\n            }\n          : null,\n      ];\n\n    // PRE-ASSIGNMENT\n    props.$defs![llmKey] = {};\n    props.$defs![humanKey] = {};\n\n    // DO COMPOSE\n    const schema: IChatGptSchema = props.$defs?.[key]!;\n    const [llm, human] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema,\n    });\n\n    // ONLY ONE\n    if (llm === null || human === null) {\n      delete props.$defs[llmKey];\n      delete props.$defs[humanKey];\n      return llm === null ? [null, props.schema] : [props.schema, null];\n    }\n\n    // BOTH OF THEM\n    return [\n      llm !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${llmKey}`,\n          }\n        : null,\n      human !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${humanKey}`,\n          }\n        : null,\n    ];\n  };\n\n  const shrinkRequired = (\n    s: IChatGptSchema.IObject,\n  ): IChatGptSchema.IObject => {\n    s.required = s.required.filter((key) => s.properties?.[key] !== undefined);\n    return s;\n  };\n\n  /* -----------------------------------------------------------\n    INVERTERS\n  ----------------------------------------------------------- */\n  export const invert = (props: {\n    components: OpenApi.IComponents;\n    schema: IChatGptSchema;\n    $defs: Record<string, IChatGptSchema>;\n  }): OpenApi.IJsonSchema => {\n    const union: OpenApi.IJsonSchema[] = [];\n    const attribute: OpenApi.IJsonSchema.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      ...Object.fromEntries(\n        Object.entries(props.schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n      example: props.schema.example,\n      examples: props.schema.examples,\n    };\n\n    const next = (schema: IChatGptSchema): OpenApi.IJsonSchema =>\n      invert({\n        components: props.components,\n        $defs: props.$defs,\n        schema,\n      });\n    const visit = (schema: IChatGptSchema): void => {\n      if (ChatGptTypeChecker.isArray(schema))\n        union.push({\n          ...LlmDescriptionInverter.array(schema.description ?? \"\"),\n          ...schema,\n          items: next(schema.items),\n        });\n      else if (ChatGptTypeChecker.isObject(schema))\n        union.push({\n          ...schema,\n          properties: Object.fromEntries(\n            Object.entries(schema.properties).map(([key, value]) => [\n              key,\n              next(value),\n            ]),\n          ),\n          additionalProperties:\n            typeof schema.additionalProperties === \"object\" &&\n            schema.additionalProperties !== null\n              ? next(schema.additionalProperties)\n              : schema.additionalProperties,\n        });\n      else if (ChatGptTypeChecker.isAnyOf(schema)) schema.anyOf.forEach(visit);\n      else if (ChatGptTypeChecker.isReference(schema)) {\n        const key: string = schema.$ref.split(\"#/$defs/\")[1];\n        if (props.components.schemas?.[key] === undefined) {\n          props.components.schemas ??= {};\n          props.components.schemas[key] = {};\n          props.components.schemas[key] = next(props.$defs[key] ?? {});\n        }\n        union.push({\n          ...schema,\n          $ref: `#/components/schemas/${key}`,\n        });\n      } else if (ChatGptTypeChecker.isBoolean(schema))\n        if (!!schema.enum?.length)\n          schema.enum.forEach((v) =>\n            union.push({\n              const: v,\n            }),\n          );\n        else union.push(schema);\n      else if (\n        ChatGptTypeChecker.isInteger(schema) ||\n        ChatGptTypeChecker.isNumber(schema)\n      )\n        if (!!schema.enum?.length)\n          schema.enum.forEach((v) =>\n            union.push({\n              const: v,\n            }),\n          );\n        else\n          union.push({\n            ...LlmDescriptionInverter.numeric(schema.description ?? \"\"),\n            ...schema,\n            ...{ enum: undefined },\n          });\n      else if (ChatGptTypeChecker.isString(schema))\n        if (!!schema.enum?.length)\n          schema.enum.forEach((v) =>\n            union.push({\n              const: v,\n            }),\n          );\n        else\n          union.push({\n            ...LlmDescriptionInverter.string(schema.description ?? \"\"),\n            ...schema,\n            ...{ enum: undefined },\n          });\n      else\n        union.push({\n          ...schema,\n        });\n    };\n    visit(props.schema);\n\n    return {\n      ...(union.length === 0\n        ? { type: undefined }\n        : union.length === 1\n          ? { ...union[0] }\n          : { oneOf: union.map((u) => ({ ...u, nullable: undefined })) }),\n      ...attribute,\n    };\n  };\n}\n"],"names":["ChatGptSchemaComposer","IS_DEFS","parameters","props","_a","config","strict","result","LlmSchemaV3_1Composer","reference","constraint","validate","validateStrict","undefined","success","key","Object","keys","value","$defs","transform","schema","oldbie","Set","has","accessor","reasons","OpenApiTypeChecker","isObject","additionalProperties","push","message","properties","required","includes","union","attribute","title","description","example","examples","fromEntries","entries","filter","startsWith","visit","input","LlmTypeCheckerV3_1","isOneOf","oneOf","forEach","isArray","items","map","isConstant","visitConstant","insert","matched","find","u","type","enum","const","length","ChatGptTypeChecker","isReference","anyOf","separateParameters","convention","NamingConvention","capitalize","llm","human","separateObject","predicate","output","endsWith","separateStation","isUnknown","isAnyOf","separateArray","separateReference","x","y","dx","dy","shrinkRequired","$ref","split","humanKey","llmKey","s","invert","next","components","LlmDescriptionInverter","array","schemas","isBoolean","v","isInteger","isNumber","numeric","isString","string","nullable"],"mappings":"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"}