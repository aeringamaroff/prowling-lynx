{"version":3,"file":"GeminiSchemaComposer.mjs","sources":["../../../src/composers/llm/GeminiSchemaComposer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { OpenApiV3 } from \"../../OpenApiV3\";\nimport { OpenApiV3_1 } from \"../../OpenApiV3_1\";\nimport { IGeminiSchema } from \"../../structures/IGeminiSchema\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3 } from \"../../structures/ILlmSchemaV3\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../typings/IResult\";\nimport { LlmTypeCheckerV3 } from \"../../utils/LlmTypeCheckerV3\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { LlmParametersFinder } from \"./LlmParametersComposer\";\nimport { LlmSchemaV3Composer } from \"./LlmSchemaV3Composer\";\n\nexport namespace GeminiSchemaComposer {\n  /**\n   * @internal\n   */\n  export const IS_DEFS = false;\n\n  export const parameters = (props: {\n    config: IGeminiSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IGeminiSchema.IParameters, IOpenApiSchemaError> => {\n    const entity: IResult<OpenApi.IJsonSchema.IObject, IOpenApiSchemaError> =\n      LlmParametersFinder.parameters({\n        ...props,\n        method: \"GeminiSchemaComposer.parameters\",\n      });\n    if (entity.success === false) return entity;\n    return schema({\n      ...props,\n      schema: entity.value,\n    }) as IResult<IGeminiSchema.IParameters, IOpenApiSchemaError>;\n  };\n\n  export const schema = (props: {\n    config: IGeminiSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IGeminiSchema, IOpenApiSchemaError> => {\n    // TRANSFORM TO LLM SCHEMA OF V3.0\n    const result: IResult<ILlmSchemaV3, IOpenApiSchemaError> =\n      LlmSchemaV3Composer.schema({\n        ...props,\n        config: {\n          recursive: props.config.recursive,\n          constraint: false,\n        },\n        validate: (next, accessor): IOpenApiSchemaError.IReason[] => {\n          if (OpenApiTypeChecker.isObject(next)) {\n            if (!!next.additionalProperties)\n              return [\n                {\n                  schema: next,\n                  accessor: `${accessor}.additionalProperties`,\n                  message: \"Gemini does not allow additionalProperties.\",\n                },\n              ];\n          } else if (\n            OpenApiTypeChecker.isOneOf(next) &&\n            isOneOf(props.components)(next)\n          )\n            return [\n              {\n                schema: next,\n                accessor: accessor,\n                message: \"Gemini does not allow union type.\",\n              },\n            ];\n          return [];\n        },\n      });\n    if (result.success === false) return result;\n\n    // SPECIALIZATIONS\n    LlmTypeCheckerV3.visit({\n      schema: result.value,\n      closure: (v) => {\n        if (v.title !== undefined) {\n          if (v.description === undefined) v.description = v.title;\n          else {\n            const title: string = v.title.endsWith(\".\")\n              ? v.title.substring(0, v.title.length - 1)\n              : v.title;\n            v.description = v.description.startsWith(title)\n              ? v.description\n              : `${title}.\\n\\n${v.description}`;\n          }\n          delete v.title;\n        }\n        if (\n          LlmTypeCheckerV3.isObject(v) &&\n          v.additionalProperties !== undefined\n        ) {\n          delete (v as Partial<ILlmSchemaV3.IObject>).additionalProperties;\n        }\n      },\n    });\n\n    // DO NOT ALLOW UNION TYPE\n    return result;\n  };\n\n  export const separateParameters = (props: {\n    predicate: (schema: IGeminiSchema) => boolean;\n    parameters: IGeminiSchema.IParameters;\n  }): ILlmFunction.ISeparated<\"gemini\"> => {\n    const separated: ILlmFunction.ISeparated<\"3.0\"> =\n      LlmSchemaV3Composer.separateParameters(\n        props as {\n          predicate: (schema: ILlmSchemaV3) => boolean;\n          parameters: ILlmSchemaV3.IParameters;\n        },\n      );\n    return separated as any as ILlmFunction.ISeparated<\"gemini\">;\n  };\n\n  export const invert = (props: {\n    schema: IGeminiSchema;\n  }): OpenApi.IJsonSchema => LlmSchemaV3Composer.invert(props);\n}\n\nconst isOneOf =\n  (components: OpenApi.IComponents) =>\n  (schema: OpenApi.IJsonSchema): boolean => {\n    const union: OpenApiV3_1.IJsonSchema[] = [];\n    const already: Set<string> = new Set();\n    const visit = (schema: OpenApi.IJsonSchema): void => {\n      if (\n        OpenApiTypeChecker.isBoolean(schema) ||\n        OpenApiTypeChecker.isInteger(schema) ||\n        OpenApiTypeChecker.isNumber(schema) ||\n        OpenApiTypeChecker.isString(schema)\n      )\n        union.push({ ...schema });\n      else if (\n        OpenApiTypeChecker.isArray(schema) ||\n        OpenApiTypeChecker.isTuple(schema) ||\n        OpenApiTypeChecker.isObject(schema)\n      )\n        union.push(schema);\n      else if (OpenApiTypeChecker.isOneOf(schema)) schema.oneOf.forEach(visit);\n      else if (OpenApiTypeChecker.isReference(schema)) {\n        if (already.has(schema.$ref)) union.push(schema);\n        else {\n          already.add(schema.$ref);\n          const target: OpenApi.IJsonSchema | undefined =\n            components.schemas?.[schema.$ref.split(\"/\").pop()!];\n          if (target === undefined) union.push(schema);\n          else visit(target);\n        }\n      }\n    };\n    const visitConstant = (schema: OpenApi.IJsonSchema): void => {\n      const insert = (value: any): void => {\n        const matched: OpenApiV3_1.IJsonSchema.INumber | undefined = union.find(\n          (u) =>\n            (u as OpenApiV3.IJsonSchema.__ISignificant<any>).type ===\n            typeof value,\n        ) as OpenApiV3.IJsonSchema.INumber | undefined;\n        if (matched !== undefined) {\n          matched.enum ??= [];\n          matched.enum.push(value);\n        } else union.push({ type: typeof value as \"number\", enum: [value] });\n      };\n      if (OpenApiTypeChecker.isConstant(schema)) insert(schema.const);\n      else if (OpenApiTypeChecker.isOneOf(schema))\n        for (const u of schema.oneOf)\n          if (OpenApiTypeChecker.isConstant(u)) insert(u.const);\n    };\n    visit(schema);\n    visitConstant(schema);\n    return union.length > 1;\n  };\n"],"names":["GeminiSchemaComposer","IS_DEFS","parameters","props","entity","LlmParametersFinder","method","success","schema","value","result","LlmSchemaV3Composer","config","recursive","constraint","validate","next","accessor","OpenApiTypeChecker","isObject","additionalProperties","message","isOneOf","components","LlmTypeCheckerV3","visit","closure","v","title","undefined","description","endsWith","substring","length","startsWith","separateParameters","separated","invert","union","already","Set","isBoolean","isInteger","isNumber","isString","push","isArray","isTuple","oneOf","forEach","isReference","has","$ref","add","target","schemas","split","pop","visitConstant","insert","matched","find","u","type","enum","isConstant","const"],"mappings":"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"}