{"version":3,"file":"LlmSchemaV3_1Composer.mjs","sources":["../../../src/composers/llm/LlmSchemaV3_1Composer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3_1 } from \"../../structures/ILlmSchemaV3_1\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../typings/IResult\";\nimport { LlmTypeCheckerV3_1 } from \"../../utils/LlmTypeCheckerV3_1\";\nimport { NamingConvention } from \"../../utils/NamingConvention\";\nimport { OpenApiConstraintShifter } from \"../../utils/OpenApiConstraintShifter\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { JsonDescriptionUtil } from \"../../utils/internal/JsonDescriptionUtil\";\nimport { LlmDescriptionInverter } from \"./LlmDescriptionInverter\";\nimport { LlmParametersFinder } from \"./LlmParametersComposer\";\n\nexport namespace LlmSchemaV3_1Composer {\n  /**\n   * @internal\n   */\n  export const IS_DEFS = true;\n\n  /* -----------------------------------------------------------\n    CONVERTERS\n  ----------------------------------------------------------- */\n  export const parameters = (props: {\n    config: ILlmSchemaV3_1.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    errors?: string[];\n    /** @internal */\n    validate?: (\n      input: OpenApi.IJsonSchema,\n      accessor: string,\n    ) => IOpenApiSchemaError.IReason[];\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<ILlmSchemaV3_1.IParameters, IOpenApiSchemaError> => {\n    const entity: IResult<OpenApi.IJsonSchema.IObject, IOpenApiSchemaError> =\n      LlmParametersFinder.parameters({\n        ...props,\n        method: \"LlmSchemaV3_1Composer.parameters\",\n      });\n    if (entity.success === false) return entity;\n\n    const $defs: Record<string, ILlmSchemaV3_1> = {};\n    const result: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> = schema({\n      ...props,\n      $defs,\n      schema: entity.value,\n    });\n    if (result.success === false) return result;\n    return {\n      success: true,\n      value: {\n        ...(result.value as ILlmSchemaV3_1.IObject),\n        additionalProperties: false,\n        $defs,\n      } satisfies ILlmSchemaV3_1.IParameters,\n    };\n  };\n\n  export const schema = (props: {\n    config: ILlmSchemaV3_1.IConfig;\n    components: OpenApi.IComponents;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: OpenApi.IJsonSchema;\n    /** @internal */\n    validate?: (\n      input: OpenApi.IJsonSchema,\n      accessor: string,\n    ) => IOpenApiSchemaError.IReason[];\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<ILlmSchemaV3_1, IOpenApiSchemaError> => {\n    const union: Array<ILlmSchemaV3_1 | null> = [];\n    const attribute: ILlmSchemaV3_1.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      example: props.schema.example,\n      examples: props.schema.examples,\n      ...Object.fromEntries(\n        Object.entries(props.schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n    };\n\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    OpenApiTypeChecker.visit({\n      closure: (next, accessor) => {\n        if (props.validate) {\n          // CUSTOM VALIDATION\n          reasons.push(...props.validate(next, accessor));\n        }\n        if (OpenApiTypeChecker.isTuple(next))\n          reasons.push({\n            schema: next,\n            accessor: accessor,\n            message: `LLM does not allow tuple type.`,\n          });\n        else if (OpenApiTypeChecker.isReference(next)) {\n          // UNABLE TO FIND MATCHED REFERENCE\n          const key = next.$ref.split(\"#/components/schemas/\")[1];\n          if (props.components.schemas?.[key] === undefined)\n            reasons.push({\n              schema: next,\n              accessor: accessor,\n              message: `unable to find reference type ${JSON.stringify(key)}.`,\n            });\n        }\n      },\n      components: props.components,\n      schema: props.schema,\n      accessor: props.accessor,\n      refAccessor: props.refAccessor,\n    });\n    if (reasons.length > 0)\n      return {\n        success: false,\n        error: {\n          method: \"LlmSchemaV3_1Composer.schema\",\n          message: \"Failed to compose LLM schema of v3.1\",\n          reasons,\n        },\n      };\n\n    const visit = (input: OpenApi.IJsonSchema, accessor: string): number => {\n      if (OpenApiTypeChecker.isOneOf(input)) {\n        // UNION TYPE\n        input.oneOf.forEach((s, i) => visit(s, `${accessor}.oneOf[${i}]`));\n        return 0;\n      } else if (OpenApiTypeChecker.isReference(input)) {\n        // REFERENCE TYPE\n        const key: string = input.$ref.split(\"#/components/schemas/\")[1];\n        const target: OpenApi.IJsonSchema | undefined =\n          props.components.schemas?.[key];\n        if (target === undefined)\n          return union.push(null); // UNREACHABLEE\n        else if (\n          // KEEP THE REFERENCE TYPE\n          props.config.reference === true ||\n          OpenApiTypeChecker.isRecursiveReference({\n            components: props.components,\n            schema: input,\n          })\n        ) {\n          const out = () =>\n            union.push({\n              ...input,\n              $ref: `#/$defs/${key}`,\n            });\n          if (props.$defs[key] !== undefined) return out();\n          props.$defs[key] = {};\n          const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n            schema({\n              config: props.config,\n              components: props.components,\n              $defs: props.$defs,\n              schema: target,\n              refAccessor: props.refAccessor,\n              accessor: `${props.refAccessor ?? \"$def\"}[${JSON.stringify(key)}]`,\n            });\n          if (converted.success === false) return union.push(null); // UNREACHABLE\n          props.$defs[key] = converted.value;\n          return out();\n        } else {\n          // DISCARD THE REFERENCE TYPE\n          const length: number = union.length;\n          visit(target, accessor);\n          if (length === union.length - 1 && union[union.length - 1] !== null)\n            union[union.length - 1] = {\n              ...union[union.length - 1]!,\n              description: JsonDescriptionUtil.cascade({\n                prefix: \"#/components/schemas/\",\n                components: props.components,\n                $ref: input.$ref,\n                description: union[union.length - 1]!.description,\n                escape: true,\n              }),\n            };\n          else\n            attribute.description = JsonDescriptionUtil.cascade({\n              prefix: \"#/components/schemas/\",\n              components: props.components,\n              $ref: input.$ref,\n              description: attribute.description,\n              escape: true,\n            });\n          return union.length;\n        }\n      } else if (OpenApiTypeChecker.isObject(input)) {\n        // OBJECT TYPE\n        const properties: Record<string, ILlmSchemaV3_1 | null> =\n          Object.entries(input.properties ?? {}).reduce(\n            (acc, [key, value]) => {\n              const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n                schema({\n                  config: props.config,\n                  components: props.components,\n                  $defs: props.$defs,\n                  schema: value,\n                  refAccessor: props.refAccessor,\n                  accessor: `${accessor}.properties[${JSON.stringify(key)}]`,\n                });\n              acc[key] = converted.success ? converted.value : null;\n              if (converted.success === false)\n                reasons.push(...converted.error.reasons);\n              return acc;\n            },\n            {} as Record<string, ILlmSchemaV3_1 | null>,\n          );\n        if (Object.values(properties).some((v) => v === null))\n          return union.push(null);\n        const additionalProperties:\n          | ILlmSchemaV3_1\n          | boolean\n          | null\n          | undefined = (() => {\n          if (\n            typeof input.additionalProperties === \"object\" &&\n            input.additionalProperties !== null\n          ) {\n            const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n              schema({\n                config: props.config,\n                components: props.components,\n                $defs: props.$defs,\n                schema: input.additionalProperties,\n                refAccessor: props.refAccessor,\n                accessor: `${accessor}.additionalProperties`,\n              });\n            if (converted.success === false) {\n              reasons.push(...converted.error.reasons);\n              return null;\n            }\n            return converted.value;\n          }\n          return input.additionalProperties;\n        })();\n        if (additionalProperties === null) return union.push(null);\n        return union.push({\n          ...input,\n          properties: properties as Record<string, ILlmSchemaV3_1>,\n          additionalProperties,\n          required: input.required ?? [],\n        });\n      } else if (OpenApiTypeChecker.isArray(input)) {\n        const items: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> = schema({\n          config: props.config,\n          components: props.components,\n          $defs: props.$defs,\n          schema: input.items,\n          refAccessor: props.refAccessor,\n          accessor: `${accessor}.items`,\n        });\n        if (items.success === false) {\n          reasons.push(...items.error.reasons);\n          return union.push(null);\n        }\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.IArray) => x\n            : (x: ILlmSchemaV3_1.IArray) =>\n                OpenApiConstraintShifter.shiftArray(x))({\n            ...input,\n            items: items.value,\n          }),\n        );\n      } else if (OpenApiTypeChecker.isString(input))\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.IString) => x\n            : (x: ILlmSchemaV3_1.IString) =>\n                OpenApiConstraintShifter.shiftString(x))({\n            ...input,\n          }),\n        );\n      else if (\n        OpenApiTypeChecker.isNumber(input) ||\n        OpenApiTypeChecker.isInteger(input)\n      )\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.INumber | ILlmSchemaV3_1.IInteger) => x\n            : (x: ILlmSchemaV3_1.INumber | ILlmSchemaV3_1.IInteger) =>\n                OpenApiConstraintShifter.shiftNumeric(x))({\n            ...input,\n          }),\n        );\n      else if (OpenApiTypeChecker.isTuple(input))\n        return union.push(null); // UNREACHABLE\n      else return union.push({ ...input });\n    };\n    visit(props.schema, props.accessor ?? \"$input.schema\");\n\n    if (union.some((u) => u === null))\n      return {\n        success: false,\n        error: {\n          method: \"LlmSchemaV3_1Composer.schema\",\n          message: \"Failed to compose LLM schema of v3.1\",\n          reasons,\n        },\n      };\n    else if (union.length === 0)\n      return {\n        success: true,\n        value: {\n          ...attribute,\n          type: undefined,\n        },\n      };\n    else if (union.length === 1)\n      return {\n        success: true,\n        value: {\n          ...attribute,\n          ...union[0]!,\n          description: LlmTypeCheckerV3_1.isReference(union[0]!)\n            ? undefined\n            : union[0]!.description,\n        },\n      };\n    return {\n      success: true,\n      value: {\n        ...attribute,\n        oneOf: union.map((u) => ({\n          ...u!,\n          description: LlmTypeCheckerV3_1.isReference(u!)\n            ? undefined\n            : u!.description,\n        })),\n      },\n    };\n  };\n\n  /* -----------------------------------------------------------\n    SEPARATORS\n  ----------------------------------------------------------- */\n  export const separateParameters = (props: {\n    parameters: ILlmSchemaV3_1.IParameters;\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention?: (key: string, type: \"llm\" | \"human\") => string;\n  }): ILlmFunction.ISeparated<\"3.1\"> => {\n    const convention =\n      props.convention ??\n      ((key, type) => `${key}.${NamingConvention.capitalize(type)}`);\n    const [llm, human] = separateObject({\n      $defs: props.parameters.$defs,\n      schema: props.parameters,\n      predicate: props.predicate,\n      convention,\n    });\n    if (llm === null || human === null)\n      return {\n        llm: (llm as ILlmSchemaV3_1.IParameters | null) ?? {\n          type: \"object\",\n          properties: {},\n          additionalProperties: false,\n          required: [],\n          $defs: {},\n        },\n        human: human as ILlmSchemaV3_1.IParameters | null,\n      };\n    const output: ILlmFunction.ISeparated<\"3.1\"> = {\n      llm: {\n        ...llm,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Llm\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n      human: {\n        ...human,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Human\"),\n          ),\n        ),\n        additionalProperties: false,\n      },\n    };\n    for (const key of Object.keys(props.parameters.$defs))\n      if (key.endsWith(\".Llm\") === false && key.endsWith(\".Human\") === false)\n        delete props.parameters.$defs[key];\n    return output;\n  };\n\n  const separateStation = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1;\n  }): [ILlmSchemaV3_1 | null, ILlmSchemaV3_1 | null] => {\n    if (props.predicate(props.schema) === true) return [null, props.schema];\n    else if (\n      LlmTypeCheckerV3_1.isUnknown(props.schema) ||\n      LlmTypeCheckerV3_1.isOneOf(props.schema)\n    )\n      return [props.schema, null];\n    else if (LlmTypeCheckerV3_1.isObject(props.schema))\n      return separateObject({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (LlmTypeCheckerV3_1.isArray(props.schema))\n      return separateArray({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    else if (LlmTypeCheckerV3_1.isReference(props.schema))\n      return separateReference({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema,\n      });\n    return [props.schema, null];\n  };\n\n  const separateArray = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1.IArray;\n  }): [ILlmSchemaV3_1.IArray | null, ILlmSchemaV3_1.IArray | null] => {\n    const [x, y] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema: props.schema.items,\n    });\n    return [\n      x !== null\n        ? {\n            ...props.schema,\n            items: x,\n          }\n        : null,\n      y !== null\n        ? {\n            ...props.schema,\n            items: y,\n          }\n        : null,\n    ];\n  };\n\n  const separateObject = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1.IObject;\n  }): [ILlmSchemaV3_1.IObject | null, ILlmSchemaV3_1.IObject | null] => {\n    // EMPTY OBJECT\n    if (\n      Object.keys(props.schema.properties ?? {}).length === 0 &&\n      !!props.schema.additionalProperties === false\n    )\n      return [props.schema, null];\n\n    const llm = {\n      ...props.schema,\n      properties: {} as Record<string, ILlmSchemaV3_1>,\n      additionalProperties: props.schema.additionalProperties,\n    } satisfies ILlmSchemaV3_1.IObject;\n    const human = {\n      ...props.schema,\n      properties: {} as Record<string, ILlmSchemaV3_1>,\n    } satisfies ILlmSchemaV3_1.IObject;\n\n    for (const [key, value] of Object.entries(props.schema.properties ?? {})) {\n      const [x, y] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: value,\n      });\n      if (x !== null) llm.properties[key] = x;\n      if (y !== null) human.properties[key] = y;\n    }\n    if (\n      typeof props.schema.additionalProperties === \"object\" &&\n      props.schema.additionalProperties !== null\n    ) {\n      const [dx, dy] = separateStation({\n        predicate: props.predicate,\n        convention: props.convention,\n        $defs: props.$defs,\n        schema: props.schema.additionalProperties,\n      });\n      llm.additionalProperties = dx ?? false;\n      human.additionalProperties = dy ?? false;\n    }\n    return [\n      !!Object.keys(llm.properties).length || !!llm.additionalProperties\n        ? shrinkRequired(llm)\n        : null,\n      !!Object.keys(human.properties).length || human.additionalProperties\n        ? shrinkRequired(human)\n        : null,\n    ];\n  };\n\n  const separateReference = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    convention: (key: string, type: \"llm\" | \"human\") => string;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: ILlmSchemaV3_1.IReference;\n  }): [ILlmSchemaV3_1.IReference | null, ILlmSchemaV3_1.IReference | null] => {\n    const key: string = props.schema.$ref.split(\"#/$defs/\")[1];\n    const humanKey: string = props.convention(key, \"human\");\n    const llmKey: string = props.convention(key, \"llm\");\n\n    // FIND EXISTING\n    if (props.$defs?.[humanKey] || props.$defs?.[llmKey])\n      return [\n        props.$defs?.[llmKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${llmKey}`,\n            }\n          : null,\n        props.$defs?.[humanKey]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${humanKey}`,\n            }\n          : null,\n      ];\n\n    // PRE-ASSIGNMENT\n    props.$defs![llmKey] = {};\n    props.$defs![humanKey] = {};\n\n    // DO COMPOSE\n    const schema: ILlmSchemaV3_1 = props.$defs?.[key]!;\n    const [llm, human] = separateStation({\n      predicate: props.predicate,\n      convention: props.convention,\n      $defs: props.$defs,\n      schema,\n    });\n\n    // ONLY ONE\n    if (llm === null || human === null) {\n      delete props.$defs[llmKey];\n      delete props.$defs[humanKey];\n      return llm === null ? [null, props.schema] : [props.schema, null];\n    }\n\n    // BOTH OF THEM\n    return [\n      llm !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${llmKey}`,\n          }\n        : null,\n      human !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${humanKey}`,\n          }\n        : null,\n    ];\n  };\n\n  const shrinkRequired = (\n    s: ILlmSchemaV3_1.IObject,\n  ): ILlmSchemaV3_1.IObject => {\n    if (s.required !== undefined)\n      s.required = s.required.filter(\n        (key) => s.properties?.[key] !== undefined,\n      );\n    return s;\n  };\n\n  /* -----------------------------------------------------------\n    INVERTERS\n  ----------------------------------------------------------- */\n  export const invert = (props: {\n    components: OpenApi.IComponents;\n    schema: ILlmSchemaV3_1;\n    $defs: Record<string, ILlmSchemaV3_1>;\n  }): OpenApi.IJsonSchema => {\n    const next = (schema: ILlmSchemaV3_1): OpenApi.IJsonSchema =>\n      invert({\n        components: props.components,\n        $defs: props.$defs,\n        schema,\n      });\n    if (LlmTypeCheckerV3_1.isArray(props.schema))\n      return {\n        ...LlmDescriptionInverter.array(props.schema.description ?? \"\"),\n        ...props.schema,\n        items: next(props.schema.items),\n      };\n    else if (LlmTypeCheckerV3_1.isObject(props.schema))\n      return {\n        ...props.schema,\n        properties: props.schema.properties\n          ? Object.fromEntries(\n              Object.entries(props.schema.properties).map(([key, value]) => [\n                key,\n                next(value),\n              ]),\n            )\n          : undefined,\n        additionalProperties:\n          typeof props.schema.additionalProperties === \"object\" &&\n          props.schema.additionalProperties !== null\n            ? next(props.schema.additionalProperties)\n            : props.schema.additionalProperties,\n      };\n    else if (LlmTypeCheckerV3_1.isReference(props.schema)) {\n      const key: string = props.schema.$ref.split(\"#/$defs/\").at(-1) ?? \"\";\n      if (props.components.schemas?.[key] === undefined) {\n        props.components.schemas ??= {};\n        props.components.schemas[key] = {};\n        props.components.schemas[key] = next(props.$defs[key] ?? {});\n      }\n      return {\n        ...props.schema,\n        $ref: `#/components/schemas/${key}`,\n      };\n    } else if (\n      LlmTypeCheckerV3_1.isInteger(props.schema) ||\n      LlmTypeCheckerV3_1.isNumber(props.schema)\n    )\n      return {\n        ...LlmDescriptionInverter.numeric(props.schema.description ?? \"\"),\n        ...props.schema,\n      };\n    else if (LlmTypeCheckerV3_1.isString(props.schema))\n      return {\n        ...LlmDescriptionInverter.string(props.schema.description ?? \"\"),\n        ...props.schema,\n      };\n    return props.schema;\n  };\n}\n"],"names":["LlmSchemaV3_1Composer","IS_DEFS","parameters","props","entity","LlmParametersFinder","method","success","$defs","result","schema","value","additionalProperties","union","attribute","title","description","example","examples","Object","fromEntries","entries","filter","key","startsWith","undefined","reasons","OpenApiTypeChecker","visit","closure","next","accessor","validate","push","isTuple","message","isReference","$ref","split","components","schemas","JSON","stringify","refAccessor","length","error","input","isOneOf","oneOf","forEach","s","i","target","config","reference","isRecursiveReference","out","converted","JsonDescriptionUtil","cascade","prefix","escape","isObject","properties","reduce","acc","values","some","v","required","isArray","items","constraint","x","OpenApiConstraintShifter","shiftArray","isString","shiftString","isNumber","isInteger","shiftNumeric","u","type","LlmTypeCheckerV3_1","map","separateParameters","convention","NamingConvention","capitalize","llm","human","separateObject","predicate","output","endsWith","keys","separateStation","isUnknown","separateArray","separateReference","y","dx","dy","shrinkRequired","humanKey","llmKey","invert","LlmDescriptionInverter","array","at","_a","numeric","string"],"mappings":";;;;;;;;;;;;;;AAaM,IAAWA;;CAAjB,SAAiBA;IAIFA,sBAAOC,UAAG;IAKVD,sBAAAE,aAAcC;QAazB,MAAMC,SACJC,oBAAoBH,WAAW;eAC1BC;YACHG,QAAQ;;QAEZ,IAAIF,OAAOG,YAAY,OAAO,OAAOH;QAErC,MAAMI,QAAwC,CAAE;QAChD,MAAMC,SAAuDT,sBAAAU,OAAO;eAC/DP;YACHK;YACAE,QAAQN,OAAOO;;QAEjB,IAAIF,OAAOF,YAAY,OAAO,OAAOE;QACrC,OAAO;YACLF,SAAS;YACTI,OAAO;mBACDF,OAAOE;gBACXC,sBAAsB;gBACtBJ;;;AAEH;IAGUR,sBAAAU,SAAUP;QAarB,MAAMU,QAAsC;QAC5C,MAAMC,YAAyC;YAC7CC,OAAOZ,MAAMO,OAAOK;YACpBC,aAAab,MAAMO,OAAOM;YAC1BC,SAASd,MAAMO,OAAOO;YACtBC,UAAUf,MAAMO,OAAOQ;eACpBC,OAAOC,YACRD,OAAOE,QAAQlB,MAAMO,QAAQY,QAC3B,EAAEC,KAAKZ,WAAWY,IAAIC,WAAW,SAASb,UAAUc;;QAK1D,MAAMC,UAAyC;QAC/CC,mBAAmBC,MAAM;YACvBC,SAAS,CAACC,MAAMC;gBACd,IAAI5B,MAAM6B,UAAU;oBAElBN,QAAQO,QAAQ9B,MAAM6B,SAASF,MAAMC;;gBAEvC,IAAIJ,mBAAmBO,QAAQJ,OAC7BJ,QAAQO,KAAK;oBACXvB,QAAQoB;oBACRC;oBACAI,SAAS;yBAER,IAAIR,mBAAmBS,YAAYN,OAAO;oBAE7C,MAAMP,MAAMO,KAAKO,KAAKC,MAAM,yBAAyB;oBACrD,IAAInC,MAAMoC,WAAWC,UAAUjB,SAASE,WACtCC,QAAQO,KAAK;wBACXvB,QAAQoB;wBACRC;wBACAI,SAAS,iCAAiCM,KAAKC,UAAUnB;;;;YAIjEgB,YAAYpC,MAAMoC;YAClB7B,QAAQP,MAAMO;YACdqB,UAAU5B,MAAM4B;YAChBY,aAAaxC,MAAMwC;;QAErB,IAAIjB,QAAQkB,SAAS,GACnB,OAAO;YACLrC,SAAS;YACTsC,OAAO;gBACLvC,QAAQ;gBACR6B,SAAS;gBACTT;;;QAIN,MAAME,QAAQ,CAACkB,OAA4Bf;YACzC,IAAIJ,mBAAmBoB,QAAQD,QAAQ;gBAErCA,MAAME,MAAMC,SAAQ,CAACC,GAAGC,MAAMvB,MAAMsB,GAAG,GAAGnB,kBAAkBoB;gBAC5D,OAAO;mBACF,IAAIxB,mBAAmBS,YAAYU,QAAQ;gBAEhD,MAAMvB,MAAcuB,MAAMT,KAAKC,MAAM,yBAAyB;gBAC9D,MAAMc,SACJjD,MAAMoC,WAAWC,UAAUjB;gBAC7B,IAAI6B,WAAW3B,WACb,OAAOZ,MAAMoB,KAAK,YACf,IAEH9B,MAAMkD,OAAOC,cAAc,QAC3B3B,mBAAmB4B,qBAAqB;oBACtChB,YAAYpC,MAAMoC;oBAClB7B,QAAQoC;oBAEV;oBACA,MAAMU,MAAM,MACV3C,MAAMoB,KAAK;2BACNa;wBACHT,MAAM,WAAWd;;oBAErB,IAAIpB,MAAMK,MAAMe,SAASE,WAAW,OAAO+B;oBAC3CrD,MAAMK,MAAMe,OAAO,CAAE;oBACrB,MAAMkC,YACJzD,sBAAAU,OAAO;wBACL2C,QAAQlD,MAAMkD;wBACdd,YAAYpC,MAAMoC;wBAClB/B,OAAOL,MAAMK;wBACbE,QAAQ0C;wBACRT,aAAaxC,MAAMwC;wBACnBZ,UAAU,GAAG5B,MAAMwC,eAAe,UAAUF,KAAKC,UAAUnB;;oBAE/D,IAAIkC,UAAUlD,YAAY,OAAO,OAAOM,MAAMoB,KAAK;oBACnD9B,MAAMK,MAAMe,OAAOkC,UAAU9C;oBAC7B,OAAO6C;uBACF;oBAEL,MAAMZ,SAAiB/B,MAAM+B;oBAC7BhB,MAAMwB,QAAQrB;oBACd,IAAIa,WAAW/B,MAAM+B,SAAS,KAAK/B,MAAMA,MAAM+B,SAAS,OAAO,MAC7D/B,MAAMA,MAAM+B,SAAS,KAAK;2BACrB/B,MAAMA,MAAM+B,SAAS;wBACxB5B,aAAa0C,oBAAoBC,QAAQ;4BACvCC,QAAQ;4BACRrB,YAAYpC,MAAMoC;4BAClBF,MAAMS,MAAMT;4BACZrB,aAAaH,MAAMA,MAAM+B,SAAS,GAAI5B;4BACtC6C,QAAQ;;4BAIZ/C,UAAUE,cAAc0C,oBAAoBC,QAAQ;wBAClDC,QAAQ;wBACRrB,YAAYpC,MAAMoC;wBAClBF,MAAMS,MAAMT;wBACZrB,aAAaF,UAAUE;wBACvB6C,QAAQ;;oBAEZ,OAAOhD,MAAM+B;;mBAEV,IAAIjB,mBAAmBmC,SAAShB,QAAQ;gBAE7C,MAAMiB,aACJ5C,OAAOE,QAAQyB,MAAMiB,cAAc,CAAA,GAAIC,QACrC,CAACC,MAAM1C,KAAKZ;oBACV,MAAM8C,YACJzD,sBAAAU,OAAO;wBACL2C,QAAQlD,MAAMkD;wBACdd,YAAYpC,MAAMoC;wBAClB/B,OAAOL,MAAMK;wBACbE,QAAQC;wBACRgC,aAAaxC,MAAMwC;wBACnBZ,UAAU,GAAGA,uBAAuBU,KAAKC,UAAUnB;;oBAEvD0C,IAAI1C,OAAOkC,UAAUlD,UAAUkD,UAAU9C,QAAQ;oBACjD,IAAI8C,UAAUlD,YAAY,OACxBmB,QAAQO,QAAQwB,UAAUZ,MAAMnB;oBAClC,OAAOuC;AAAG,oBAEZ;gBAEJ,IAAI9C,OAAO+C,OAAOH,YAAYI,MAAMC,KAAMA,MAAM,QAC9C,OAAOvD,MAAMoB,KAAK;gBACpB,MAAMrB,uBAIU;oBACd,WACSkC,MAAMlC,yBAAyB,YACtCkC,MAAMlC,yBAAyB,MAC/B;wBACA,MAAM6C,YACJzD,sBAAAU,OAAO;4BACL2C,QAAQlD,MAAMkD;4BACdd,YAAYpC,MAAMoC;4BAClB/B,OAAOL,MAAMK;4BACbE,QAAQoC,MAAMlC;4BACd+B,aAAaxC,MAAMwC;4BACnBZ,UAAU,GAAGA;;wBAEjB,IAAI0B,UAAUlD,YAAY,OAAO;4BAC/BmB,QAAQO,QAAQwB,UAAUZ,MAAMnB;4BAChC,OAAO;;wBAET,OAAO+B,UAAU9C;;oBAEnB,OAAOmC,MAAMlC;AACd,kBArBe;gBAsBhB,IAAIA,yBAAyB,MAAM,OAAOC,MAAMoB,KAAK;gBACrD,OAAOpB,MAAMoB,KAAK;uBACba;oBACHiB;oBACAnD;oBACAyD,UAAUvB,MAAMuB,YAAY;;mBAEzB,IAAI1C,mBAAmB2C,QAAQxB,QAAQ;gBAC5C,MAAMyB,QAAsDvE,sBAAAU,OAAO;oBACjE2C,QAAQlD,MAAMkD;oBACdd,YAAYpC,MAAMoC;oBAClB/B,OAAOL,MAAMK;oBACbE,QAAQoC,MAAMyB;oBACd5B,aAAaxC,MAAMwC;oBACnBZ,UAAU,GAAGA;;gBAEf,IAAIwC,MAAMhE,YAAY,OAAO;oBAC3BmB,QAAQO,QAAQsC,MAAM1B,MAAMnB;oBAC5B,OAAOb,MAAMoB,KAAK;;gBAEpB,OAAOpB,MAAMoB,MACV9B,MAAMkD,OAAOmB,aACTC,KAA6BA,IAC7BA,KACCC,yBAAyBC,WAAWF,IAAI;uBACzC3B;oBACHyB,OAAOA,MAAM5D;;mBAGZ,IAAIgB,mBAAmBiD,SAAS9B,QACrC,OAAOjC,MAAMoB,MACV9B,MAAMkD,OAAOmB,aACTC,KAA8BA,IAC9BA,KACCC,yBAAyBG,YAAYJ,IAAI;mBAC1C3B;sBAGJ,IACHnB,mBAAmBmD,SAAShC,UAC5BnB,mBAAmBoD,UAAUjC,QAE7B,OAAOjC,MAAMoB,MACV9B,MAAMkD,OAAOmB,aACTC,KAAwDA,IACxDA,KACCC,yBAAyBM,aAAaP,IAAI;mBAC3C3B;sBAGJ,IAAInB,mBAAmBO,QAAQY,QAClC,OAAOjC,MAAMoB,KAAK,YACf,OAAOpB,MAAMoB,KAAK;mBAAKa;;AAAQ;QAEtClB,MAAMzB,MAAMO,QAAQP,MAAM4B,YAAY;QAEtC,IAAIlB,MAAMsD,MAAMc,KAAMA,MAAM,QAC1B,OAAO;YACL1E,SAAS;YACTsC,OAAO;gBACLvC,QAAQ;gBACR6B,SAAS;gBACTT;;gBAGD,IAAIb,MAAM+B,WAAW,GACxB,OAAO;YACLrC,SAAS;YACTI,OAAO;mBACFG;gBACHoE,MAAMzD;;gBAGP,IAAIZ,MAAM+B,WAAW,GACxB,OAAO;YACLrC,SAAS;YACTI,OAAO;mBACFG;mBACAD,MAAM;gBACTG,aAAamE,mBAAmB/C,YAAYvB,MAAM,MAC9CY,YACAZ,MAAM,GAAIG;;;QAGpB,OAAO;YACLT,SAAS;YACTI,OAAO;mBACFG;gBACHkC,OAAOnC,MAAMuE,KAAKH,MAAO;uBACpBA;oBACHjE,aAAamE,mBAAmB/C,YAAY6C,KACxCxD,YACAwD,EAAGjE;;;;AAGZ;IAMUhB,sBAAAqF,qBAAsBlF;QAKjC,MAAMmF,aACJnF,MAAMmF,cACN,EAAE/D,KAAK2D,SAAS,GAAG3D,OAAOgE,iBAAiBC,WAAWN;QACxD,OAAOO,KAAKC,SAASC,eAAe;YAClCnF,OAAOL,MAAMD,WAAWM;YACxBE,QAAQP,MAAMD;YACd0F,WAAWzF,MAAMyF;YACjBN;;QAEF,IAAIG,QAAQ,QAAQC,UAAU,MAC5B,OAAO;YACLD,KAAMA,OAA6C;gBACjDP,MAAM;gBACNnB,YAAY,CAAE;gBACdnD,sBAAsB;gBACtByD,UAAU;gBACV7D,OAAO,CAAE;;YAEXkF;;QAEJ,MAAMG,SAAyC;YAC7CJ,KAAK;mBACAA;gBACHjF,OAAOW,OAAOC,YACZD,OAAOE,QAAQlB,MAAMD,WAAWM,OAAOc,QAAO,EAAEC,SAC9CA,IAAIuE,SAAS;gBAGjBlF,sBAAsB;;YAExB8E,OAAO;mBACFA;gBACHlF,OAAOW,OAAOC,YACZD,OAAOE,QAAQlB,MAAMD,WAAWM,OAAOc,QAAO,EAAEC,SAC9CA,IAAIuE,SAAS;gBAGjBlF,sBAAsB;;;QAG1B,KAAK,MAAMW,OAAOJ,OAAO4E,KAAK5F,MAAMD,WAAWM,QAC7C,IAAIe,IAAIuE,SAAS,YAAY,SAASvE,IAAIuE,SAAS,cAAc,cACxD3F,MAAMD,WAAWM,MAAMe;QAClC,OAAOsE;AAAM;IAGf,MAAMG,kBAAmB7F;QAMvB,IAAIA,MAAMyF,UAAUzF,MAAMO,YAAY,MAAM,OAAO,EAAC,MAAMP,MAAMO,eAC3D,IACHyE,mBAAmBc,UAAU9F,MAAMO,WACnCyE,mBAAmBpC,QAAQ5C,MAAMO,SAEjC,OAAO,EAACP,MAAMO,QAAQ,aACnB,IAAIyE,mBAAmBrB,SAAS3D,MAAMO,SACzC,OAAOiF,eAAe;YACpBC,WAAWzF,MAAMyF;YACjBN,YAAYnF,MAAMmF;YAClB9E,OAAOL,MAAMK;YACbE,QAAQP,MAAMO;iBAEb,IAAIyE,mBAAmBb,QAAQnE,MAAMO,SACxC,OAAOwF,cAAc;YACnBN,WAAWzF,MAAMyF;YACjBN,YAAYnF,MAAMmF;YAClB9E,OAAOL,MAAMK;YACbE,QAAQP,MAAMO;iBAEb,IAAIyE,mBAAmB/C,YAAYjC,MAAMO,SAC5C,OAAOyF,kBAAkB;YACvBP,WAAWzF,MAAMyF;YACjBN,YAAYnF,MAAMmF;YAClB9E,OAAOL,MAAMK;YACbE,QAAQP,MAAMO;;QAElB,OAAO,EAACP,MAAMO,QAAQ;AAAK;IAG7B,MAAMwF,gBAAiB/F;QAMrB,OAAOsE,GAAG2B,KAAKJ,gBAAgB;YAC7BJ,WAAWzF,MAAMyF;YACjBN,YAAYnF,MAAMmF;YAClB9E,OAAOL,MAAMK;YACbE,QAAQP,MAAMO,OAAO6D;;QAEvB,OAAO,EACLE,MAAM,OACF;eACKtE,MAAMO;YACT6D,OAAOE;YAET,MACJ2B,MAAM,OACF;eACKjG,MAAMO;YACT6D,OAAO6B;YAET;AACL;IAGH,MAAMT,iBAAkBxF;QAOtB,IACEgB,OAAO4E,KAAK5F,MAAMO,OAAOqD,cAAc,CAAE,GAAEnB,WAAW,OACpDzC,MAAMO,OAAOE,yBAAyB,OAExC,OAAO,EAACT,MAAMO,QAAQ;QAExB,MAAM+E,MAAM;eACPtF,MAAMO;YACTqD,YAAY,CAAoC;YAChDnD,sBAAsBT,MAAMO,OAAOE;;QAErC,MAAM8E,QAAQ;eACTvF,MAAMO;YACTqD,YAAY,CAAoC;;QAGlD,KAAK,OAAOxC,KAAKZ,UAAUQ,OAAOE,QAAQlB,MAAMO,OAAOqD,cAAc,CAAA,IAAK;YACxE,OAAOU,GAAG2B,KAAKJ,gBAAgB;gBAC7BJ,WAAWzF,MAAMyF;gBACjBN,YAAYnF,MAAMmF;gBAClB9E,OAAOL,MAAMK;gBACbE,QAAQC;;YAEV,IAAI8D,MAAM,MAAMgB,IAAI1B,WAAWxC,OAAOkD;YACtC,IAAI2B,MAAM,MAAMV,MAAM3B,WAAWxC,OAAO6E;;QAE1C,WACSjG,MAAMO,OAAOE,yBAAyB,YAC7CT,MAAMO,OAAOE,yBAAyB,MACtC;YACA,OAAOyF,IAAIC,MAAMN,gBAAgB;gBAC/BJ,WAAWzF,MAAMyF;gBACjBN,YAAYnF,MAAMmF;gBAClB9E,OAAOL,MAAMK;gBACbE,QAAQP,MAAMO,OAAOE;;YAEvB6E,IAAI7E,uBAAuByF,MAAM;YACjCX,MAAM9E,uBAAuB0F,MAAM;;QAErC,OAAO,IACHnF,OAAO4E,KAAKN,IAAI1B,YAAYnB,YAAY6C,IAAI7E,uBAC1C2F,eAAed,OACf,QACFtE,OAAO4E,KAAKL,MAAM3B,YAAYnB,UAAU8C,MAAM9E,uBAC5C2F,eAAeb,SACf;AACL;IAGH,MAAMS,oBAAqBhG;QAMzB,MAAMoB,MAAcpB,MAAMO,OAAO2B,KAAKC,MAAM,YAAY;QACxD,MAAMkE,WAAmBrG,MAAMmF,WAAW/D,KAAK;QAC/C,MAAMkF,SAAiBtG,MAAMmF,WAAW/D,KAAK;QAG7C,IAAIpB,MAAMK,QAAQgG,aAAarG,MAAMK,QAAQiG,SAC3C,OAAO,EACLtG,MAAMK,QAAQiG,UACV;eACKtG,MAAMO;YACT2B,MAAM,WAAWoE;YAEnB,MACJtG,MAAMK,QAAQgG,YACV;eACKrG,MAAMO;YACT2B,MAAM,WAAWmE;YAEnB;QAIRrG,MAAMK,MAAOiG,UAAU,CAAE;QACzBtG,MAAMK,MAAOgG,YAAY,CAAE;QAG3B,MAAM9F,SAAyBP,MAAMK,QAAQe;QAC7C,OAAOkE,KAAKC,SAASM,gBAAgB;YACnCJ,WAAWzF,MAAMyF;YACjBN,YAAYnF,MAAMmF;YAClB9E,OAAOL,MAAMK;YACbE;;QAIF,IAAI+E,QAAQ,QAAQC,UAAU,MAAM;mBAC3BvF,MAAMK,MAAMiG;mBACZtG,MAAMK,MAAMgG;YACnB,OAAOf,QAAQ,OAAO,EAAC,MAAMtF,MAAMO,WAAU,EAACP,MAAMO,QAAQ;;QAI9D,OAAO,EACL+E,QAAQ,OACJ;eACKtF,MAAMO;YACT2B,MAAM,WAAWoE;YAEnB,MACJf,UAAU,OACN;eACKvF,MAAMO;YACT2B,MAAM,WAAWmE;YAEnB;AACL;IAGH,MAAMD,iBACJrD;QAEA,IAAIA,EAAEmB,aAAa5C,WACjByB,EAAEmB,WAAWnB,EAAEmB,SAAS/C,QACrBC,OAAQ2B,EAAEa,aAAaxC,SAASE;QAErC,OAAOyB;AAAC;IAMGlD,sBAAA0G,SAAUvG;;QAKrB,MAAM2B,OAAQpB,UACZV,sBAAA0G,OAAO;YACLnE,YAAYpC,MAAMoC;YAClB/B,OAAOL,MAAMK;YACbE;;QAEJ,IAAIyE,mBAAmBb,QAAQnE,MAAMO,SACnC,OAAO;eACFiG,uBAAuBC,MAAMzG,MAAMO,OAAOM,eAAe;eACzDb,MAAMO;YACT6D,OAAOzC,KAAK3B,MAAMO,OAAO6D;gBAExB,IAAIY,mBAAmBrB,SAAS3D,MAAMO,SACzC,OAAO;eACFP,MAAMO;YACTqD,YAAY5D,MAAMO,OAAOqD,aACrB5C,OAAOC,YACLD,OAAOE,QAAQlB,MAAMO,OAAOqD,YAAYqB,KAAI,EAAE7D,KAAKZ,WAAW,EAC5DY,KACAO,KAAKnB,cAGTc;YACJb,6BACST,MAAMO,OAAOE,yBAAyB,YAC7CT,MAAMO,OAAOE,yBAAyB,OAClCkB,KAAK3B,MAAMO,OAAOE,wBAClBT,MAAMO,OAAOE;gBAElB,IAAIuE,mBAAmB/C,YAAYjC,MAAMO,SAAS;YACrD,MAAMa,MAAcpB,MAAMO,OAAO2B,KAAKC,MAAM,YAAYuE,IAAK,MAAK;YAClE,IAAI1G,MAAMoC,WAAWC,UAAUjB,SAASE,WAAW;iBACjDqF,KAAA3G,MAAMoC,YAAWC,YAAAsE,GAAAtE,UAAY;gBAC7BrC,MAAMoC,WAAWC,QAAQjB,OAAO,CAAE;gBAClCpB,MAAMoC,WAAWC,QAAQjB,OAAOO,KAAK3B,MAAMK,MAAMe,QAAQ;;YAE3D,OAAO;mBACFpB,MAAMO;gBACT2B,MAAM,wBAAwBd;;eAE3B,IACL4D,mBAAmBJ,UAAU5E,MAAMO,WACnCyE,mBAAmBL,SAAS3E,MAAMO,SAElC,OAAO;eACFiG,uBAAuBI,QAAQ5G,MAAMO,OAAOM,eAAe;eAC3Db,MAAMO;gBAER,IAAIyE,mBAAmBP,SAASzE,MAAMO,SACzC,OAAO;eACFiG,uBAAuBK,OAAO7G,MAAMO,OAAOM,eAAe;eAC1Db,MAAMO;;QAEb,OAAOP,MAAMO;AAAM;AAEtB,EAznBD,CAAiBV,0BAAAA,wBAynBhB,CAAA;;"}