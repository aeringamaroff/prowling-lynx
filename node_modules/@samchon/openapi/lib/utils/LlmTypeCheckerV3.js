"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LlmTypeCheckerV3 = void 0;
/**
 * Type checker for LLM type schema.
 *
 * `LlmSchemaTypeChecker` is a type checker of {@link ILlmSchemaV3}.
 *
 * @author Samchon
 */
var LlmTypeCheckerV3;
(function (LlmTypeCheckerV3) {
    /* -----------------------------------------------------------
      OPERATORS
    ----------------------------------------------------------- */
    /**
     * Visit every nested schemas.
     *
     * Visit every nested schemas of the target, and apply the `props.closure` function.
     *
     * Here is the list of occurring nested visitings:
     *
     * - {@link ILlmSchemaV3.IOneOf.oneOf}
     * - {@link ILlmSchemaV3.IObject.additionalProperties}
     * - {@link ILlmSchemaV3.IArray.items}
     *
     * @param props Properties for visiting
     */
    LlmTypeCheckerV3.visit = function (props) {
        var e_1, _a;
        var _b;
        var accessor = (_b = props.accessor) !== null && _b !== void 0 ? _b : "$input.schema";
        props.closure(props.schema, accessor);
        if (LlmTypeCheckerV3.isOneOf(props.schema))
            props.schema.oneOf.forEach(function (s, i) {
                return LlmTypeCheckerV3.visit({
                    closure: props.closure,
                    schema: s,
                    accessor: "".concat(accessor, ".oneOf[").concat(i, "]"),
                });
            });
        else if (LlmTypeCheckerV3.isObject(props.schema)) {
            try {
                for (var _c = __values(Object.entries(props.schema.properties)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), k = _e[0], s = _e[1];
                    LlmTypeCheckerV3.visit({
                        closure: props.closure,
                        schema: s,
                        accessor: "".concat(accessor, ".properties[").concat(JSON.stringify(k), "]"),
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (typeof props.schema.additionalProperties === "object" &&
                props.schema.additionalProperties !== null)
                LlmTypeCheckerV3.visit({
                    closure: props.closure,
                    schema: props.schema.additionalProperties,
                    accessor: "".concat(accessor, ".additionalProperties"),
                });
        }
        else if (LlmTypeCheckerV3.isArray(props.schema))
            LlmTypeCheckerV3.visit({
                closure: props.closure,
                schema: props.schema.items,
                accessor: "".concat(accessor, ".items"),
            });
    };
    LlmTypeCheckerV3.covers = function (x, y) {
        var alpha = flatSchema(x);
        var beta = flatSchema(y);
        if (alpha.some(function (x) { return LlmTypeCheckerV3.isUnknown(x); }))
            return true;
        else if (beta.some(function (x) { return LlmTypeCheckerV3.isUnknown(x); }))
            return false;
        return beta.every(function (b) {
            return alpha.some(function (a) {
                // CHECK EQUALITY
                if (a === b)
                    return true;
                else if (LlmTypeCheckerV3.isUnknown(a))
                    return true;
                else if (LlmTypeCheckerV3.isUnknown(b))
                    return false;
                else if (LlmTypeCheckerV3.isNullOnly(a))
                    return LlmTypeCheckerV3.isNullOnly(b);
                else if (LlmTypeCheckerV3.isNullOnly(b))
                    return LlmTypeCheckerV3.isNullable(a);
                else if (LlmTypeCheckerV3.isNullable(a) && !LlmTypeCheckerV3.isNullable(b))
                    return false;
                // ATOMIC CASE
                else if (LlmTypeCheckerV3.isBoolean(a))
                    return LlmTypeCheckerV3.isBoolean(b) && coverBoolean(a, b);
                else if (LlmTypeCheckerV3.isInteger(a))
                    return LlmTypeCheckerV3.isInteger(b) && coverInteger(a, b);
                else if (LlmTypeCheckerV3.isNumber(a))
                    return (LlmTypeCheckerV3.isNumber(b) || LlmTypeCheckerV3.isInteger(b)) && coverNumber(a, b);
                else if (LlmTypeCheckerV3.isString(a))
                    return LlmTypeCheckerV3.isString(b) && covertString(a, b);
                // INSTANCE CASE
                else if (LlmTypeCheckerV3.isArray(a))
                    return LlmTypeCheckerV3.isArray(b) && coverArray(a, b);
                else if (LlmTypeCheckerV3.isObject(a))
                    return LlmTypeCheckerV3.isObject(b) && coverObject(a, b);
                else if (LlmTypeCheckerV3.isOneOf(a))
                    return false;
            });
        });
    };
    /**
     * @internal
     */
    var coverBoolean = function (x, y) {
        return x.enum === undefined ||
            (y.enum !== undefined && x.enum.every(function (v) { return y.enum.includes(v); }));
    };
    /**
     * @internal
     */
    var coverInteger = function (x, y) {
        if (x.enum !== undefined)
            return y.enum !== undefined && x.enum.every(function (v) { return y.enum.includes(v); });
        return [
            x.type === y.type,
            x.minimum === undefined ||
                (y.minimum !== undefined && x.minimum <= y.minimum),
            x.maximum === undefined ||
                (y.maximum !== undefined && x.maximum >= y.maximum),
            x.exclusiveMinimum !== true ||
                x.minimum === undefined ||
                (y.minimum !== undefined &&
                    (y.exclusiveMinimum === true || x.minimum < y.minimum)),
            x.exclusiveMaximum !== true ||
                x.maximum === undefined ||
                (y.maximum !== undefined &&
                    (y.exclusiveMaximum === true || x.maximum > y.maximum)),
            x.multipleOf === undefined ||
                (y.multipleOf !== undefined &&
                    y.multipleOf / x.multipleOf ===
                        Math.floor(y.multipleOf / x.multipleOf)),
        ].every(function (v) { return v; });
    };
    /**
     * @internal
     */
    var coverNumber = function (x, y) {
        if (x.enum !== undefined)
            return y.enum !== undefined && x.enum.every(function (v) { return y.enum.includes(v); });
        return [
            x.type === y.type || (x.type === "number" && y.type === "integer"),
            x.minimum === undefined ||
                (y.minimum !== undefined && x.minimum <= y.minimum),
            x.maximum === undefined ||
                (y.maximum !== undefined && x.maximum >= y.maximum),
            x.exclusiveMinimum !== true ||
                x.minimum === undefined ||
                (y.minimum !== undefined &&
                    (y.exclusiveMinimum === true || x.minimum < y.minimum)),
            x.exclusiveMaximum !== true ||
                x.maximum === undefined ||
                (y.maximum !== undefined &&
                    (y.exclusiveMaximum === true || x.maximum > y.maximum)),
            x.multipleOf === undefined ||
                (y.multipleOf !== undefined &&
                    y.multipleOf / x.multipleOf ===
                        Math.floor(y.multipleOf / x.multipleOf)),
        ].every(function (v) { return v; });
    };
    /**
     * @internal
     */
    var covertString = function (x, y) {
        if (x.enum !== undefined)
            return y.enum !== undefined && x.enum.every(function (v) { return y.enum.includes(v); });
        return [
            x.type === y.type,
            x.format === undefined ||
                (y.format !== undefined && coverFormat(x.format, y.format)),
            x.pattern === undefined || x.pattern === y.pattern,
            x.minLength === undefined ||
                (y.minLength !== undefined && x.minLength <= y.minLength),
            x.maxLength === undefined ||
                (y.maxLength !== undefined && x.maxLength >= y.maxLength),
        ].every(function (v) { return v; });
    };
    var coverFormat = function (x, y) {
        return x === y ||
            (x === "idn-email" && y === "email") ||
            (x === "idn-hostname" && y === "hostname") ||
            (["uri", "iri"].includes(x) && y === "url") ||
            (x === "iri" && y === "uri") ||
            (x === "iri-reference" && y === "uri-reference");
    };
    /**
     * @internal
     */
    var coverArray = function (x, y) { return LlmTypeCheckerV3.covers(x.items, y.items); };
    var coverObject = function (x, y) {
        var _a;
        if (!x.additionalProperties && !!y.additionalProperties)
            return false;
        else if ((!!x.additionalProperties &&
            !!y.additionalProperties &&
            typeof x.additionalProperties === "object" &&
            y.additionalProperties === true) ||
            (typeof x.additionalProperties === "object" &&
                typeof y.additionalProperties === "object" &&
                !LlmTypeCheckerV3.covers(x.additionalProperties, y.additionalProperties)))
            return false;
        return Object.entries((_a = y.properties) !== null && _a !== void 0 ? _a : {}).every(function (_a) {
            var _b, _c, _d, _e, _f;
            var _g = __read(_a, 2), key = _g[0], b = _g[1];
            var a = (_b = x.properties) === null || _b === void 0 ? void 0 : _b[key];
            if (a === undefined)
                return false;
            else if (((_d = (_c = x.required) === null || _c === void 0 ? void 0 : _c.includes(key)) !== null && _d !== void 0 ? _d : false) === true &&
                ((_f = (_e = y.required) === null || _e === void 0 ? void 0 : _e.includes(key)) !== null && _f !== void 0 ? _f : false) === false)
                return false;
            return LlmTypeCheckerV3.covers(a, b);
        });
    };
    var flatSchema = function (schema) {
        return LlmTypeCheckerV3.isOneOf(schema) ? schema.oneOf.flatMap(flatSchema) : [schema];
    };
    /* -----------------------------------------------------------
      TYPE CHECKERS
    ----------------------------------------------------------- */
    /**
     * Test whether the schema is an union type.
     *
     * @param schema Target schema
     * @returns Whether union type or not
     */
    LlmTypeCheckerV3.isOneOf = function (schema) {
        return schema.oneOf !== undefined;
    };
    /**
     * Test whether the schema is an object type.
     *
     * @param schema Target schema
     * @returns Whether object type or not
     */
    LlmTypeCheckerV3.isObject = function (schema) {
        return schema.type === "object";
    };
    /**
     * Test whether the schema is an array type.
     *
     * @param schema Target schema
     * @returns Whether array type or not
     */
    LlmTypeCheckerV3.isArray = function (schema) {
        return schema.type === "array";
    };
    /**
     * Test whether the schema is a boolean type.
     *
     * @param schema Target schema
     * @returns Whether boolean type or not
     */
    LlmTypeCheckerV3.isBoolean = function (schema) {
        return schema.type === "boolean";
    };
    /**
     * Test whether the schema is an integer type.
     *
     * @param schema Target schema
     * @returns Whether integer type or not
     */
    LlmTypeCheckerV3.isInteger = function (schema) {
        return schema.type === "integer";
    };
    /**
     * Test whether the schema is a number type.
     *
     * @param schema Target schema
     * @returns Whether number type or not
     */
    LlmTypeCheckerV3.isNumber = function (schema) {
        return schema.type === "number";
    };
    /**
     * Test whether the schema is a string type.
     *
     * @param schema Target schema
     * @returns Whether string type or not
     */
    LlmTypeCheckerV3.isString = function (schema) {
        return schema.type === "string";
    };
    /**
     * Test whether the schema is a null type.
     *
     * @param schema Target schema
     * @returns Whether null type or not
     */
    LlmTypeCheckerV3.isNullOnly = function (schema) {
        return schema.type === "null";
    };
    /**
     * Test whether the schema is a nullable type.
     *
     * @param schema Target schema
     * @returns Whether nullable type or not
     */
    LlmTypeCheckerV3.isNullable = function (schema) {
        return !LlmTypeCheckerV3.isUnknown(schema) &&
            (LlmTypeCheckerV3.isNullOnly(schema) ||
                (LlmTypeCheckerV3.isOneOf(schema)
                    ? schema.oneOf.some(LlmTypeCheckerV3.isNullable)
                    : schema.nullable === true));
    };
    /**
     * Test whether the schema is an unknown type.
     *
     * @param schema Target schema
     * @returns Whether unknown type or not
     */
    LlmTypeCheckerV3.isUnknown = function (schema) {
        return !LlmTypeCheckerV3.isOneOf(schema) && schema.type === undefined;
    };
})(LlmTypeCheckerV3 || (exports.LlmTypeCheckerV3 = LlmTypeCheckerV3 = {}));
